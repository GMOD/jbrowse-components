# @jbrowse/core Developer Guide

## package.json Structure

This package uses a dual-mode configuration to support both monorepo development and
external consumers.

### Exports Field

The `exports` field defines subpath imports like `@jbrowse/core/PluginManager`. During
development, these point to source TypeScript files:

```json
"exports": {
  ".": "./src/index.ts",
  "./PluginManager": "./src/PluginManager.ts"
}
```

### publishConfig

When the package is published to npm, the `publishConfig` section overrides the exports
to point to compiled output:

```json
"publishConfig": {
  "exports": {
    "./PluginManager": {
      "types": "./esm/PluginManager.d.ts",
      "import": "./esm/PluginManager.js"
    }
  }
}
```

### typesVersions (for moduleResolution "node" consumers)

The `exports` field is only supported by TypeScript with `moduleResolution` set to
`bundler`, `node16`, or `nodenext`. For consumers using the legacy `moduleResolution: "node"`,
we include a `typesVersions` field in `publishConfig`:

```json
"publishConfig": {
  "typesVersions": {
    "*": {
      "PluginManager": ["esm/PluginManager.d.ts"]
    }
  }
}
```

This tells TypeScript where to find type declarations for subpath imports even when
the `exports` field is not being read.

## Generating Exports

The exports, publishConfig.exports, and publishConfig.typesVersions are all
auto-generated by scanning the codebase for `@jbrowse/core/*` imports:

```bash
pnpm generate:exports
```

This script (`scripts/generateExports.mjs`) finds all imports of `@jbrowse/core/*`
across the monorepo and generates the appropriate mappings.

## Module Resolution Summary

| Consumer Environment | How it resolves `@jbrowse/core/PluginManager` |
|---------------------|-----------------------------------------------|
| Monorepo (bundler mode) | Uses `exports` field pointing to `src/*.ts` |
| External (bundler/node16/nodenext) | Uses `publishConfig.exports` pointing to `esm/*.js` |
| External (node mode) | Uses `typesVersions` for types, `exports` for runtime |
