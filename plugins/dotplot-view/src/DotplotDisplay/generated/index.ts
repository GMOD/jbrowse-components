// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const DOTPLOT_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    float x1_;
    float y1_;
    float x2_;
    float y2_;
    vec4 color;
    float _pad1_;
    float _pad2_;
    float _pad3_;
    float _pad4_;
};
struct Uniforms {
    vec2 resolution;
    float offsetX;
    float offsetY;
    float lineWidth;
    float scaleX;
    float scaleY;
    float _pad;
};
struct VOut {
    vec4 pos;
    vec4 color;
    float dist;
};
uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 12;
    Instance s;
    s.x1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.y1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.x2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.y2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    s._pad1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 8) / 4, 0), 0)[(base + 8) % 4]);
    s._pad2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 9) / 4, 0), 0)[(base + 9) % 4]);
    s._pad3_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 10) / 4, 0), 0)[(base + 10) % 4]);
    s._pad4_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 11) / 4, 0), 0)[(base + 11) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;
smooth out float _vs2fs_location1;

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VOut out_ = VOut(vec4(0.0), vec4(0.0), 0.0);
    vec2 normal = vec2(0.0);
    Instance inst = _fetch_Instance(int(iid));
    out_.color = inst.color;
    out_.dist = 0.0;
    float _e13 = _group_0_binding_1_vs.scaleX;
    float _e17 = _group_0_binding_1_vs.offsetX;
    float sx1_ = ((inst.x1_ * _e13) - _e17);
    float _e22 = _group_0_binding_1_vs.resolution.y;
    float _e26 = _group_0_binding_1_vs.scaleY;
    float _e30 = _group_0_binding_1_vs.offsetY;
    float sy1_ = (_e22 - ((inst.y1_ * _e26) - _e30));
    float _e36 = _group_0_binding_1_vs.scaleX;
    float _e40 = _group_0_binding_1_vs.offsetX;
    float sx2_ = ((inst.x2_ * _e36) - _e40);
    float _e45 = _group_0_binding_1_vs.resolution.y;
    float _e49 = _group_0_binding_1_vs.scaleY;
    float _e53 = _group_0_binding_1_vs.offsetY;
    float sy2_ = (_e45 - ((inst.y2_ * _e49) - _e53));
    float templateT[6] = float[6](0.0, 0.0, 1.0, 1.0, 0.0, 1.0);
    float templateSide[6] = float[6](-1.0, 1.0, -1.0, -1.0, 1.0, 1.0);
    float t = templateT[vid];
    float side = templateSide[vid];
    float x = mix(sx1_, sx2_, t);
    float y = mix(sy1_, sy2_, t);
    float dx = (sx2_ - sx1_);
    float dy = (sy2_ - sy1_);
    float len = sqrt(((dx * dx) + (dy * dy)));
    if ((len > 0.001)) {
        float dirX = (dx / len);
        float dirY = (dy / len);
        normal = vec2(-(dirY), dirX);
    } else {
        normal = vec2(0.0, 1.0);
    }
    vec2 _e91 = normal;
    float _e95 = _group_0_binding_1_vs.lineWidth;
    vec2 pos = (vec2(x, y) + (((_e91 * side) * _e95) * 0.5));
    vec2 _e102 = _group_0_binding_1_vs.resolution;
    vec2 clipSpace = (((pos / _e102) * 2.0) - vec2(1.0));
    out_.pos = vec4(clipSpace.x, -(clipSpace.y), 0.0, 1.0);
    out_.dist = side;
    VOut _e117 = out_;
    gl_Position = _e117.pos;
    _vs2fs_location0 = _e117.color;
    _vs2fs_location1 = _e117.dist;
    return;
}

`

export const DOTPLOT_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VOut {
    vec4 pos;
    vec4 color;
    float dist;
};
smooth in vec4 _vs2fs_location0;
smooth in float _vs2fs_location1;
out vec4 _fs2p_location0;

void main() {
    VOut in_ = VOut(gl_FragCoord, _vs2fs_location0, _vs2fs_location1);
    float d = abs(in_.dist);
    float aa = fwidth(in_.dist);
    float edgeAlpha = (1.0 - smoothstep((0.5 - (aa * 0.5)), (0.5 + aa), d));
    float finalAlpha = (in_.color.w * edgeAlpha);
    _fs2p_location0 = vec4((in_.color.xyz * finalAlpha), finalAlpha);
    return;
}

`
