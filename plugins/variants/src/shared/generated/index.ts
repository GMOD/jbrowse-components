// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const VARIANT_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct CellInstance {
    uvec2 start_end;
    uint row_index;
    uint shape_type;
    vec4 color;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    float canvas_width;
    float row_height;
    float scroll_top;
    float u_zero;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

CellInstance _fetch_CellInstance(int idx) {
    int base = idx * 8;
    CellInstance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.row_index = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.shape_type = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range, float zero) {
    float inf = (1.0 / zero);
    float step_ = (2.0 / bp_range.z);
    float hi_1 = max((split_pos.x - bp_range.x), -(inf));
    float lo_1 = max((split_pos.y - bp_range.y), -(inf));
    return dot(vec3(-1.0, hi_1, lo_1), vec3(1.0, step_, step_));
}

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    float cx1_ = 0.0;
    float cx2_ = 0.0;
    float y_bot = 0.0;
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    CellInstance inst = _fetch_CellInstance(int(instance_index));
    uint vid = (vertex_index % 6u);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec2 _e20 = hp_split_uint(abs_end);
    vec3 _e23 = _group_0_binding_1_vs.bp_range_x;
    float _e26 = _group_0_binding_1_vs.u_zero;
    float _e27 = hp_to_clip_x(_e19, _e23, _e26);
    vec3 _e30 = _group_0_binding_1_vs.bp_range_x;
    float _e33 = _group_0_binding_1_vs.u_zero;
    float _e34 = hp_to_clip_x(_e20, _e30, _e33);
    float _e37 = _group_0_binding_1_vs.canvas_width;
    float px_size = (2.0 / _e37);
    cx1_ = (floor(((_e27 / px_size) + 0.5)) * px_size);
    cx2_ = (floor(((_e34 / px_size) + 0.5)) * px_size);
    float _e52 = cx2_;
    float _e53 = cx1_;
    if (((_e52 - _e53) < (2.0 * px_size))) {
        float _e58 = cx1_;
        cx2_ = (_e58 + (2.0 * px_size));
    }
    float _e66 = _group_0_binding_1_vs.row_height;
    float _e70 = _group_0_binding_1_vs.scroll_top;
    float y_top_px = ((float(inst.row_index) * _e66) - _e70);
    float y_top = floor((y_top_px + 0.5));
    float _e77 = _group_0_binding_1_vs.row_height;
    y_bot = floor(((y_top_px + _e77) + 0.5));
    float _e83 = y_bot;
    if (((_e83 - y_top) < 1.0)) {
        y_bot = (y_top + 1.0);
    }
    float _e89 = y_bot;
    float y_mid = ((y_top + _e89) * 0.5);
    float _e95 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip_y = (2.0 / _e95);
    float cy_top = (1.0 - (y_top * px_to_clip_y));
    float _e101 = y_bot;
    float cy_bot = (1.0 - (_e101 * px_to_clip_y));
    float cy_mid = (1.0 - (y_mid * px_to_clip_y));
    float _e108 = cx1_;
    float _e109 = cx2_;
    float x_mid = ((_e108 + _e109) * 0.5);
    if ((inst.shape_type == 0u)) {
        if (!((vid == 0u))) {
            local = (vid == 2u);
        } else {
            local = true;
        }
        bool _e126 = local;
        if (!(_e126)) {
            local_1 = (vid == 3u);
        } else {
            local_1 = true;
        }
        bool _e133 = local_1;
        float lx = (_e133 ? 0.0 : 1.0);
        if (!((vid == 0u))) {
            local_2 = (vid == 1u);
        } else {
            local_2 = true;
        }
        bool _e145 = local_2;
        if (!(_e145)) {
            local_3 = (vid == 4u);
        } else {
            local_3 = true;
        }
        bool _e152 = local_3;
        float ly = (_e152 ? 0.0 : 1.0);
        float _e156 = cx1_;
        float _e157 = cx2_;
        sx = mix(_e156, _e157, lx);
        sy = mix(cy_bot, cy_top, ly);
    } else {
        if ((inst.shape_type == 1u)) {
            switch(vid) {
                case 0u: {
                    float _e163 = cx1_;
                    sx = _e163;
                    sy = cy_top;
                    break;
                }
                case 1u: {
                    float _e164 = cx1_;
                    sx = _e164;
                    sy = cy_bot;
                    break;
                }
                default: {
                    float _e165 = cx2_;
                    sx = _e165;
                    sy = cy_mid;
                    break;
                }
            }
        } else {
            if ((inst.shape_type == 2u)) {
                switch(vid) {
                    case 0u: {
                        float _e169 = cx2_;
                        sx = _e169;
                        sy = cy_top;
                        break;
                    }
                    case 1u: {
                        float _e170 = cx2_;
                        sx = _e170;
                        sy = cy_bot;
                        break;
                    }
                    default: {
                        float _e171 = cx1_;
                        sx = _e171;
                        sy = cy_mid;
                        break;
                    }
                }
            } else {
                float _e174 = _group_0_binding_1_vs.canvas_width;
                float width_extend = (6.0 / _e174);
                switch(vid) {
                    case 0u: {
                        float _e177 = cx1_;
                        sx = (_e177 - width_extend);
                        sy = cy_top;
                        break;
                    }
                    case 1u: {
                        float _e179 = cx2_;
                        sx = (_e179 + width_extend);
                        sy = cy_top;
                        break;
                    }
                    default: {
                        sx = x_mid;
                        sy = cy_bot;
                        break;
                    }
                }
            }
        }
    }
    float _e183 = sx;
    float _e184 = sy;
    out_.position = vec4(_e183, _e184, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e190 = out_;
    gl_Position = _e190.position;
    _vs2fs_location0 = _e190.color;
    return;
}

`

export const VARIANT_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = vec4((in_.color.xyz * in_.color.w), in_.color.w);
    return;
}

`

export const VARIANT_MATRIX_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct CellInstance {
    float feature_index;
    uint row_index;
    uint _pad0_;
    uint _pad1_;
    vec4 color;
};
struct Uniforms {
    float num_features;
    float canvas_width;
    float canvas_height;
    float row_height;
    float scroll_top;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
uniform highp usampler2D u_instanceData;

CellInstance _fetch_CellInstance(int idx) {
    int base = idx * 8;
    CellInstance s;
    s.feature_index = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.row_index = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s._pad0_ = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s._pad1_ = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float cx1_ = 0.0;
    float cx2_ = 0.0;
    float y_bot = 0.0;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    CellInstance inst = _fetch_CellInstance(int(instance_index));
    uint vid = (vertex_index % 6u);
    if (!((vid == 0u))) {
        local = (vid == 2u);
    } else {
        local = true;
    }
    bool _e15 = local;
    if (!(_e15)) {
        local_1 = (vid == 3u);
    } else {
        local_1 = true;
    }
    bool _e22 = local_1;
    float lx = (_e22 ? 0.0 : 1.0);
    if (!((vid == 0u))) {
        local_2 = (vid == 1u);
    } else {
        local_2 = true;
    }
    bool _e34 = local_2;
    if (!(_e34)) {
        local_3 = (vid == 4u);
    } else {
        local_3 = true;
    }
    bool _e41 = local_3;
    float ly = (_e41 ? 0.0 : 1.0);
    float _e48 = _group_0_binding_1_vs.num_features;
    float x1_ = (inst.feature_index / _e48);
    float _e55 = _group_0_binding_1_vs.num_features;
    float x2_ = ((inst.feature_index + 1.0) / _e55);
    float _e59 = _group_0_binding_1_vs.canvas_width;
    float px_size_x = (1.0 / _e59);
    cx1_ = (floor(((x1_ / px_size_x) + 0.5)) * px_size_x);
    cx2_ = (floor(((x2_ / px_size_x) + 0.5)) * px_size_x);
    float _e74 = cx2_;
    float _e75 = cx1_;
    if (((_e74 - _e75) < px_size_x)) {
        float _e78 = cx1_;
        cx2_ = (_e78 + px_size_x);
    }
    float _e80 = cx1_;
    float _e81 = cx2_;
    float clip_x = ((mix(_e80, _e81, lx) * 2.0) - 1.0);
    float _e91 = _group_0_binding_1_vs.row_height;
    float _e95 = _group_0_binding_1_vs.scroll_top;
    float y_top_px = ((float(inst.row_index) * _e91) - _e95);
    float y_top = floor((y_top_px + 0.5));
    float _e102 = _group_0_binding_1_vs.row_height;
    y_bot = floor(((y_top_px + _e102) + 0.5));
    float _e108 = y_bot;
    if (((_e108 - y_top) < 1.0)) {
        y_bot = (y_top + 1.0);
    }
    float _e116 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip_y = (2.0 / _e116);
    float _e119 = y_bot;
    float clip_y = mix((1.0 - (_e119 * px_to_clip_y)), (1.0 - (y_top * px_to_clip_y)), ly);
    out_.position = vec4(clip_x, clip_y, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e134 = out_;
    gl_Position = _e134.position;
    _vs2fs_location0 = _e134.color;
    return;
}

`

export const VARIANT_MATRIX_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = vec4((in_.color.xyz * in_.color.w), in_.color.w);
    return;
}

`
