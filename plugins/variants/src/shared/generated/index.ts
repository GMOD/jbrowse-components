// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const VARIANT_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct CellInstance {
    uvec2 start_end;
    uint row_index;
    uint shape_type;
    vec4 color;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    float canvas_width;
    float row_height;
    float scroll_top;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

CellInstance _fetch_CellInstance(int idx) {
    int base = idx * 8;
    CellInstance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.row_index = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.shape_type = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

layout(location = 0) smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    float cx1_ = 0.0;
    float cx2_ = 0.0;
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    CellInstance inst = _fetch_CellInstance(int(instance_index));
    uint vid = (vertex_index % 6u);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec2 _e20 = hp_split_uint(abs_end);
    vec3 _e23 = _group_0_binding_1_vs.bp_range_x;
    float _e24 = hp_to_clip_x(_e19, _e23);
    vec3 _e27 = _group_0_binding_1_vs.bp_range_x;
    float _e28 = hp_to_clip_x(_e20, _e27);
    float _e31 = _group_0_binding_1_vs.canvas_width;
    float px_size = (2.0 / _e31);
    cx1_ = (floor(((_e24 / px_size) + 0.5)) * px_size);
    cx2_ = (floor(((_e28 / px_size) + 0.5)) * px_size);
    float _e46 = cx2_;
    float _e47 = cx1_;
    if (((_e46 - _e47) < (2.0 * px_size))) {
        float _e52 = cx1_;
        cx2_ = (_e52 + (2.0 * px_size));
    }
    float _e60 = _group_0_binding_1_vs.row_height;
    float _e64 = _group_0_binding_1_vs.scroll_top;
    float y_top_px = ((float(inst.row_index) * _e60) - _e64);
    float _e68 = _group_0_binding_1_vs.row_height;
    float y_bot_px = (y_top_px + _e68);
    float y_top = floor((y_top_px + 0.5));
    float y_bot = floor((y_bot_px + 0.5));
    float y_mid = ((y_top + y_bot) * 0.5);
    float _e81 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip_y = (2.0 / _e81);
    float cy_top = (1.0 - (y_top * px_to_clip_y));
    float cy_bot = (1.0 - (y_bot * px_to_clip_y));
    float cy_mid = (1.0 - (y_mid * px_to_clip_y));
    float _e93 = cx1_;
    float _e94 = cx2_;
    float x_mid = ((_e93 + _e94) * 0.5);
    if ((inst.shape_type == 0u)) {
        if (!((vid == 0u))) {
            local = (vid == 2u);
        } else {
            local = true;
        }
        bool _e111 = local;
        if (!(_e111)) {
            local_1 = (vid == 3u);
        } else {
            local_1 = true;
        }
        bool _e118 = local_1;
        float lx = (_e118 ? 0.0 : 1.0);
        if (!((vid == 0u))) {
            local_2 = (vid == 1u);
        } else {
            local_2 = true;
        }
        bool _e130 = local_2;
        if (!(_e130)) {
            local_3 = (vid == 4u);
        } else {
            local_3 = true;
        }
        bool _e137 = local_3;
        float ly = (_e137 ? 0.0 : 1.0);
        float _e141 = cx1_;
        float _e142 = cx2_;
        sx = mix(_e141, _e142, lx);
        sy = mix(cy_bot, cy_top, ly);
    } else {
        if ((inst.shape_type == 1u)) {
            switch(vid) {
                case 0u: {
                    float _e148 = cx1_;
                    sx = _e148;
                    sy = cy_top;
                    break;
                }
                case 1u: {
                    float _e149 = cx1_;
                    sx = _e149;
                    sy = cy_bot;
                    break;
                }
                default: {
                    float _e150 = cx2_;
                    sx = _e150;
                    sy = cy_mid;
                    break;
                }
            }
        } else {
            if ((inst.shape_type == 2u)) {
                switch(vid) {
                    case 0u: {
                        float _e154 = cx2_;
                        sx = _e154;
                        sy = cy_top;
                        break;
                    }
                    case 1u: {
                        float _e155 = cx2_;
                        sx = _e155;
                        sy = cy_bot;
                        break;
                    }
                    default: {
                        float _e156 = cx1_;
                        sx = _e156;
                        sy = cy_mid;
                        break;
                    }
                }
            } else {
                float _e159 = _group_0_binding_1_vs.canvas_width;
                float width_extend = (6.0 / _e159);
                switch(vid) {
                    case 0u: {
                        float _e162 = cx1_;
                        sx = (_e162 - width_extend);
                        sy = cy_top;
                        break;
                    }
                    case 1u: {
                        float _e164 = cx2_;
                        sx = (_e164 + width_extend);
                        sy = cy_top;
                        break;
                    }
                    default: {
                        sx = x_mid;
                        sy = cy_bot;
                        break;
                    }
                }
            }
        }
    }
    float _e168 = sx;
    float _e169 = sy;
    out_.position = vec4(_e168, _e169, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e175 = out_;
    gl_Position = _e175.position;
    _vs2fs_location0 = _e175.color;
    return;
}

`

export const VARIANT_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

layout(location = 0) smooth in vec4 _vs2fs_location0;
layout(location = 0) out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = vec4((in_.color.xyz * in_.color.w), in_.color.w);
    return;
}

`

export const VARIANT_MATRIX_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct CellInstance {
    float feature_index;
    uint row_index;
    uint _pad0_;
    uint _pad1_;
    vec4 color;
};
struct Uniforms {
    float num_features;
    float canvas_width;
    float canvas_height;
    float row_height;
    float scroll_top;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
uniform highp usampler2D u_instanceData;

CellInstance _fetch_CellInstance(int idx) {
    int base = idx * 8;
    CellInstance s;
    s.feature_index = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.row_index = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s._pad0_ = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s._pad1_ = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

layout(location = 0) smooth out vec4 _vs2fs_location0;

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float cx1_ = 0.0;
    float cx2_ = 0.0;
    float y_bot = 0.0;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    CellInstance inst = _fetch_CellInstance(int(instance_index));
    uint vid = (vertex_index % 6u);
    if (!((vid == 0u))) {
        local = (vid == 2u);
    } else {
        local = true;
    }
    bool _e15 = local;
    if (!(_e15)) {
        local_1 = (vid == 3u);
    } else {
        local_1 = true;
    }
    bool _e22 = local_1;
    float lx = (_e22 ? 0.0 : 1.0);
    if (!((vid == 0u))) {
        local_2 = (vid == 1u);
    } else {
        local_2 = true;
    }
    bool _e34 = local_2;
    if (!(_e34)) {
        local_3 = (vid == 4u);
    } else {
        local_3 = true;
    }
    bool _e41 = local_3;
    float ly = (_e41 ? 0.0 : 1.0);
    float _e48 = _group_0_binding_1_vs.num_features;
    float x1_ = (inst.feature_index / _e48);
    float _e55 = _group_0_binding_1_vs.num_features;
    float x2_ = ((inst.feature_index + 1.0) / _e55);
    float _e59 = _group_0_binding_1_vs.canvas_width;
    float px_size_x = (1.0 / _e59);
    cx1_ = (floor(((x1_ / px_size_x) + 0.5)) * px_size_x);
    cx2_ = (floor(((x2_ / px_size_x) + 0.5)) * px_size_x);
    float _e74 = cx2_;
    float _e75 = cx1_;
    if (((_e74 - _e75) < px_size_x)) {
        float _e78 = cx1_;
        cx2_ = (_e78 + px_size_x);
    }
    float _e80 = cx1_;
    float _e81 = cx2_;
    float clip_x = ((mix(_e80, _e81, lx) * 2.0) - 1.0);
    float _e91 = _group_0_binding_1_vs.row_height;
    float _e95 = _group_0_binding_1_vs.scroll_top;
    float y_top_px = ((float(inst.row_index) * _e91) - _e95);
    float y_top = floor((y_top_px + 0.5));
    float _e102 = _group_0_binding_1_vs.row_height;
    y_bot = floor(((y_top_px + _e102) + 0.5));
    float _e108 = y_bot;
    if (((_e108 - y_top) < 1.0)) {
        y_bot = (y_top + 1.0);
    }
    float _e116 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip_y = (2.0 / _e116);
    float _e119 = y_bot;
    float clip_y = mix((1.0 - (_e119 * px_to_clip_y)), (1.0 - (y_top * px_to_clip_y)), ly);
    out_.position = vec4(clip_x, clip_y, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e134 = out_;
    gl_Position = _e134.position;
    _vs2fs_location0 = _e134.color;
    return;
}

`

export const VARIANT_MATRIX_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
layout(location = 0) smooth in vec4 _vs2fs_location0;
layout(location = 0) out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = vec4((in_.color.xyz * in_.color.w), in_.color.w);
    return;
}

`

