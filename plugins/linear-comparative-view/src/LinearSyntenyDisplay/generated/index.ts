// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const FILL_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    float x1_;
    float x2_;
    float x3_;
    float x4_;
    vec4 color;
    float featureId;
    float isCurve;
    float queryTotalLength;
    float padTop;
    float padBottom;
    float _pad1_;
    float _pad2_;
    float _pad3_;
};
struct Uniforms {
    vec2 resolution;
    float height;
    float adjOff0_;
    float adjOff1_;
    float scale0_;
    float scale1_;
    float maxOffScreenPx;
    float minAlignmentLength;
    float alpha;
    uint instanceCount;
    uint fillSegments;
    uint edgeSegments;
    float hoveredFeatureId;
    float clickedFeatureId;
    float _pad1u;
};
struct VOut {
    vec4 pos;
    vec4 color;
    float featureId;
    float dist;
    float halfWidth;
};
uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 16;
    Instance s;
    s.x1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.x2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.x3_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.x4_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    s.featureId = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 8) / 4, 0), 0)[(base + 8) % 4]);
    s.isCurve = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 9) / 4, 0), 0)[(base + 9) % 4]);
    s.queryTotalLength = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 10) / 4, 0), 0)[(base + 10) % 4]);
    s.padTop = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 11) / 4, 0), 0)[(base + 11) % 4]);
    s.padBottom = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 12) / 4, 0), 0)[(base + 12) % 4]);
    s._pad1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 13) / 4, 0), 0)[(base + 13) % 4]);
    s._pad2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 14) / 4, 0), 0)[(base + 14) % 4]);
    s._pad3_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 15) / 4, 0), 0)[(base + 15) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;
flat out float _vs2fs_location1;
smooth out float _vs2fs_location2;
smooth out float _vs2fs_location3;

vec3 hermiteEdges(float screenX1_, float screenX2_, float screenX3_, float screenX4_, float t_1, float isCurve) {
    float edge0_ = 0.0;
    float edge1_ = 0.0;
    float y = 0.0;
    if ((isCurve > 0.5)) {
        float s = ((t_1 * t_1) * (3.0 - (2.0 * t_1)));
        edge0_ = mix(screenX1_, screenX4_, s);
        edge1_ = mix(screenX2_, screenX3_, s);
        float _e21 = _group_0_binding_1_vs.height;
        y = (_e21 * (((1.5 * t_1) * (1.0 - t_1)) + ((t_1 * t_1) * t_1)));
    } else {
        edge0_ = mix(screenX1_, screenX4_, t_1);
        edge1_ = mix(screenX2_, screenX3_, t_1);
        float _e35 = _group_0_binding_1_vs.height;
        y = (t_1 * _e35);
    }
    float _e37 = edge0_;
    float _e38 = edge1_;
    float _e39 = y;
    return vec3(_e37, _e38, _e39);
}

bool isCulled(Instance inst) {
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float _e3 = _group_0_binding_1_vs.minAlignmentLength;
    if ((_e3 > 0.0)) {
        float _e11 = _group_0_binding_1_vs.minAlignmentLength;
        local = (inst.queryTotalLength < _e11);
    } else {
        local = false;
    }
    bool _e14 = local;
    if (_e14) {
        return true;
    }
    float _e19 = _group_0_binding_1_vs.adjOff0_;
    float _e23 = _group_0_binding_1_vs.scale0_;
    float _e28 = _group_0_binding_1_vs.scale0_;
    float topX1_ = (((inst.x1_ - _e19) * _e23) - (inst.padTop * (_e28 - 1.0)));
    float _e36 = _group_0_binding_1_vs.adjOff0_;
    float _e40 = _group_0_binding_1_vs.scale0_;
    float _e45 = _group_0_binding_1_vs.scale0_;
    float topX2_ = (((inst.x2_ - _e36) * _e40) - (inst.padTop * (_e45 - 1.0)));
    float _e53 = _group_0_binding_1_vs.adjOff1_;
    float _e57 = _group_0_binding_1_vs.scale1_;
    float _e62 = _group_0_binding_1_vs.scale1_;
    float botX3_ = (((inst.x3_ - _e53) * _e57) - (inst.padBottom * (_e62 - 1.0)));
    float _e70 = _group_0_binding_1_vs.adjOff1_;
    float _e74 = _group_0_binding_1_vs.scale1_;
    float _e79 = _group_0_binding_1_vs.scale1_;
    float botX4_ = (((inst.x4_ - _e70) * _e74) - (inst.padBottom * (_e79 - 1.0)));
    float topMinX = min(topX1_, topX2_);
    float topMaxX = max(topX1_, topX2_);
    float botMinX = min(botX3_, botX4_);
    float botMaxX = max(botX3_, botX4_);
    float mOff = _group_0_binding_1_vs.maxOffScreenPx;
    float rW = _group_0_binding_1_vs.resolution.x;
    if (!((topMaxX < -(mOff)))) {
        local_1 = (topMinX > (rW + mOff));
    } else {
        local_1 = true;
    }
    bool _e103 = local_1;
    if (!(_e103)) {
        local_2 = (botMaxX < -(mOff));
    } else {
        local_2 = true;
    }
    bool _e110 = local_2;
    if (!(_e110)) {
        local_3 = (botMinX > (rW + mOff));
    } else {
        local_3 = true;
    }
    bool _e117 = local_3;
    return _e117;
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VOut out_ = VOut(vec4(0.0), vec4(0.0), 0.0, 0.0, 0.0);
    float t0_ = 0.0;
    float t1_ = 0.0;
    uint nUpper = 0u;
    float t = 0.0;
    float side = 0.0;
    Instance inst_1 = _fetch_Instance(int(iid));
    out_.color = inst_1.color;
    out_.featureId = inst_1.featureId;
    out_.dist = 0.0;
    out_.halfWidth = 0.0;
    bool _e14 = isCulled(inst_1);
    if (_e14) {
        out_.pos = vec4(0.0, 0.0, 0.0, 0.0);
        VOut _e21 = out_;
        gl_Position = _e21.pos;
        _vs2fs_location0 = _e21.color;
        _vs2fs_location1 = _e21.featureId;
        _vs2fs_location2 = _e21.dist;
        _vs2fs_location3 = _e21.halfWidth;
        return;
    }
    float _e25 = _group_0_binding_1_vs.adjOff0_;
    float _e29 = _group_0_binding_1_vs.scale0_;
    float _e34 = _group_0_binding_1_vs.scale0_;
    float screenX1_1 = (((inst_1.x1_ - _e25) * _e29) - (inst_1.padTop * (_e34 - 1.0)));
    float _e42 = _group_0_binding_1_vs.adjOff0_;
    float _e46 = _group_0_binding_1_vs.scale0_;
    float _e51 = _group_0_binding_1_vs.scale0_;
    float screenX2_1 = (((inst_1.x2_ - _e42) * _e46) - (inst_1.padTop * (_e51 - 1.0)));
    float _e59 = _group_0_binding_1_vs.adjOff1_;
    float _e63 = _group_0_binding_1_vs.scale1_;
    float _e68 = _group_0_binding_1_vs.scale1_;
    float screenX3_1 = (((inst_1.x3_ - _e59) * _e63) - (inst_1.padBottom * (_e68 - 1.0)));
    float _e76 = _group_0_binding_1_vs.adjOff1_;
    float _e80 = _group_0_binding_1_vs.scale1_;
    float _e85 = _group_0_binding_1_vs.scale1_;
    float screenX4_1 = (((inst_1.x4_ - _e76) * _e80) - (inst_1.padBottom * (_e85 - 1.0)));
    uint segs = _group_0_binding_1_vs.fillSegments;
    uint seg = (vid / 6u);
    uint vertInSeg = (vid % 6u);
    float topDiff = (screenX1_1 - screenX2_1);
    float botDiff = (screenX4_1 - screenX3_1);
    if (((topDiff * botDiff) < 0.0)) {
        float tCross = clamp((topDiff / (topDiff - botDiff)), 0.01, 0.99);
        nUpper = uint(roundEven((float(segs) * tCross)));
        uint _e114 = nUpper;
        nUpper = min(max(_e114, 1u), (segs - 1u));
        uint _e119 = nUpper;
        if ((seg < _e119)) {
            uint _e122 = nUpper;
            t0_ = ((float(seg) / float(_e122)) * tCross);
            uint _e129 = nUpper;
            t1_ = ((float((seg + 1u)) / float(_e129)) * tCross);
        } else {
            uint _e133 = nUpper;
            uint lSeg = (seg - _e133);
            uint _e135 = nUpper;
            uint nLower = (segs - _e135);
            t0_ = (tCross + ((float(lSeg) / float(nLower)) * (1.0 - tCross)));
            t1_ = (tCross + ((float((lSeg + 1u)) / float(nLower)) * (1.0 - tCross)));
        }
    } else {
        t0_ = (float(seg) / float(segs));
        t1_ = (float((seg + 1u)) / float(segs));
    }
    switch(vertInSeg) {
        case 0u: {
            float _e163 = t0_;
            t = _e163;
            side = 0.0;
            break;
        }
        case 1u: {
            float _e165 = t0_;
            t = _e165;
            side = 1.0;
            break;
        }
        case 2u: {
            float _e167 = t1_;
            t = _e167;
            side = 0.0;
            break;
        }
        case 3u: {
            float _e169 = t1_;
            t = _e169;
            side = 0.0;
            break;
        }
        case 4u: {
            float _e171 = t0_;
            t = _e171;
            side = 1.0;
            break;
        }
        case 5u: {
            float _e173 = t1_;
            t = _e173;
            side = 1.0;
            break;
        }
        default: {
            t = 0.0;
            side = 0.0;
            break;
        }
    }
    float _e177 = t;
    vec3 _e179 = hermiteEdges(screenX1_1, screenX2_1, screenX3_1, screenX4_1, _e177, inst_1.isCurve);
    float centerX = ((_e179.x + _e179.y) * 0.5);
    float halfWidth = (abs((_e179.x - _e179.y)) * 0.5);
    float _e191 = side;
    float dir = ((_e191 * 2.0) - 1.0);
    float expandedHalfWidth = (halfWidth + 0.5);
    float x = (centerX + (dir * expandedHalfWidth));
    vec2 _e204 = _group_0_binding_1_vs.resolution;
    vec2 clipSpace = (((vec2(x, _e179.z) / _e204) * 2.0) - vec2(1.0));
    out_.pos = vec4(clipSpace.x, -(clipSpace.y), 0.0, 1.0);
    out_.dist = (dir * expandedHalfWidth);
    out_.halfWidth = halfWidth;
    VOut _e221 = out_;
    gl_Position = _e221.pos;
    _vs2fs_location0 = _e221.color;
    _vs2fs_location1 = _e221.featureId;
    _vs2fs_location2 = _e221.dist;
    _vs2fs_location3 = _e221.halfWidth;
    return;
}

`

export const FILL_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct Uniforms {
    vec2 resolution;
    float height;
    float adjOff0_;
    float adjOff1_;
    float scale0_;
    float scale1_;
    float maxOffScreenPx;
    float minAlignmentLength;
    float alpha;
    uint instanceCount;
    uint fillSegments;
    uint edgeSegments;
    float hoveredFeatureId;
    float clickedFeatureId;
    float _pad1u;
};
struct VOut {
    vec4 pos;
    vec4 color;
    float featureId;
    float dist;
    float halfWidth;
};
layout(std140) uniform Uniforms_block_0Fragment { Uniforms _group_0_binding_1_fs; };

smooth in vec4 _vs2fs_location0;
flat in float _vs2fs_location1;
smooth in float _vs2fs_location2;
smooth in float _vs2fs_location3;
out vec4 _fs2p_location0;

void main() {
    VOut in_ = VOut(gl_FragCoord, _vs2fs_location0, _vs2fs_location1, _vs2fs_location2, _vs2fs_location3);
    vec3 rgb = vec3(0.0);
    bool local = false;
    rgb = in_.color.xyz;
    float _e6 = _group_0_binding_1_fs.hoveredFeatureId;
    if ((_e6 > 0.0)) {
        float _e14 = _group_0_binding_1_fs.hoveredFeatureId;
        local = (abs((in_.featureId - _e14)) < 0.5);
    } else {
        local = false;
    }
    bool isHovered = local;
    float _e25 = _group_0_binding_1_fs.alpha;
    float baseAlpha = (in_.color.w * _e25);
    float finalAlpha = (isHovered ? min((baseAlpha * 5.0), 0.35) : baseAlpha);
    if (isHovered) {
        vec3 _e32 = rgb;
        rgb = (_e32 * 0.7);
    }
    float coverage = clamp(((in_.halfWidth + 0.5) - abs(in_.dist)), 0.0, 1.0);
    vec3 _e42 = rgb;
    _fs2p_location0 = vec4(_e42, (finalAlpha * coverage));
    return;
}

`

export const FILL_FRAGMENT_SHADER_PICKING = `#version 300 es

precision highp float;
precision highp int;

struct VOut {
    vec4 pos;
    vec4 color;
    float featureId;
    float dist;
    float halfWidth;
};
smooth in vec4 _vs2fs_location0;
flat in float _vs2fs_location1;
smooth in float _vs2fs_location2;
smooth in float _vs2fs_location3;
out vec4 _fs2p_location0;

void main() {
    VOut in_ = VOut(gl_FragCoord, _vs2fs_location0, _vs2fs_location1, _vs2fs_location2, _vs2fs_location3);
    if ((abs(in_.dist) > in_.halfWidth)) {
        discard;
    }
    uint id = uint(in_.featureId);
    float r = (float((id & 255u)) / 255.0);
    float g = (float(((id >> 8u) & 255u)) / 255.0);
    float b = (float(((id >> 16u) & 255u)) / 255.0);
    _fs2p_location0 = vec4(r, g, b, 1.0);
    return;
}

`

export const EDGE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    float x1_;
    float x2_;
    float x3_;
    float x4_;
    vec4 color;
    float featureId;
    float isCurve;
    float queryTotalLength;
    float padTop;
    float padBottom;
    float _pad1_;
    float _pad2_;
    float _pad3_;
};
struct Uniforms {
    vec2 resolution;
    float height;
    float adjOff0_;
    float adjOff1_;
    float scale0_;
    float scale1_;
    float maxOffScreenPx;
    float minAlignmentLength;
    float alpha;
    uint instanceCount;
    uint fillSegments;
    uint edgeSegments;
    float hoveredFeatureId;
    float clickedFeatureId;
    float _pad1u;
};
struct VOut {
    vec4 pos;
    float dist;
};
uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 16;
    Instance s;
    s.x1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.x2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.x3_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.x4_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    s.featureId = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 8) / 4, 0), 0)[(base + 8) % 4]);
    s.isCurve = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 9) / 4, 0), 0)[(base + 9) % 4]);
    s.queryTotalLength = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 10) / 4, 0), 0)[(base + 10) % 4]);
    s.padTop = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 11) / 4, 0), 0)[(base + 11) % 4]);
    s.padBottom = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 12) / 4, 0), 0)[(base + 12) % 4]);
    s._pad1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 13) / 4, 0), 0)[(base + 13) % 4]);
    s._pad2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 14) / 4, 0), 0)[(base + 14) % 4]);
    s._pad3_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 15) / 4, 0), 0)[(base + 15) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out float _vs2fs_location0;

bool isCulled(Instance inst) {
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    bool local_5 = false;
    float _e3 = _group_0_binding_1_vs.minAlignmentLength;
    if ((_e3 > 0.0)) {
        float _e11 = _group_0_binding_1_vs.minAlignmentLength;
        local_2 = (inst.queryTotalLength < _e11);
    } else {
        local_2 = false;
    }
    bool _e14 = local_2;
    if (_e14) {
        return true;
    }
    float _e19 = _group_0_binding_1_vs.adjOff0_;
    float _e23 = _group_0_binding_1_vs.scale0_;
    float _e28 = _group_0_binding_1_vs.scale0_;
    float topX1_ = (((inst.x1_ - _e19) * _e23) - (inst.padTop * (_e28 - 1.0)));
    float _e36 = _group_0_binding_1_vs.adjOff0_;
    float _e40 = _group_0_binding_1_vs.scale0_;
    float _e45 = _group_0_binding_1_vs.scale0_;
    float topX2_ = (((inst.x2_ - _e36) * _e40) - (inst.padTop * (_e45 - 1.0)));
    float _e53 = _group_0_binding_1_vs.adjOff1_;
    float _e57 = _group_0_binding_1_vs.scale1_;
    float _e62 = _group_0_binding_1_vs.scale1_;
    float botX3_ = (((inst.x3_ - _e53) * _e57) - (inst.padBottom * (_e62 - 1.0)));
    float _e70 = _group_0_binding_1_vs.adjOff1_;
    float _e74 = _group_0_binding_1_vs.scale1_;
    float _e79 = _group_0_binding_1_vs.scale1_;
    float botX4_ = (((inst.x4_ - _e70) * _e74) - (inst.padBottom * (_e79 - 1.0)));
    float topMinX = min(topX1_, topX2_);
    float topMaxX = max(topX1_, topX2_);
    float botMinX = min(botX3_, botX4_);
    float botMaxX = max(botX3_, botX4_);
    float mOff = _group_0_binding_1_vs.maxOffScreenPx;
    float rW = _group_0_binding_1_vs.resolution.x;
    if (!((topMaxX < -(mOff)))) {
        local_3 = (topMinX > (rW + mOff));
    } else {
        local_3 = true;
    }
    bool _e103 = local_3;
    if (!(_e103)) {
        local_4 = (botMaxX < -(mOff));
    } else {
        local_4 = true;
    }
    bool _e110 = local_4;
    if (!(_e110)) {
        local_5 = (botMinX > (rW + mOff));
    } else {
        local_5 = true;
    }
    bool _e117 = local_5;
    return _e117;
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VOut out_ = VOut(vec4(0.0), 0.0);
    bool local = false;
    bool local_1 = false;
    float t = 0.0;
    float side = 0.0;
    float edge0_x = 0.0;
    float edge1_x = 0.0;
    float y = 0.0;
    vec2 tangent = vec2(0.0);
    vec2 normal = vec2(0.0);
    vec2 pos = vec2(0.0);
    Instance inst_1 = _fetch_Instance(int(iid));
    out_.dist = 0.0;
    float _e10 = _group_0_binding_1_vs.clickedFeatureId;
    if ((_e10 > 0.0)) {
        float _e18 = _group_0_binding_1_vs.clickedFeatureId;
        local = (abs((inst_1.featureId - _e18)) < 0.5);
    } else {
        local = false;
    }
    bool isClicked = local;
    if (!(!(isClicked))) {
        bool _e29 = isCulled(inst_1);
        local_1 = _e29;
    } else {
        local_1 = true;
    }
    bool _e31 = local_1;
    if (_e31) {
        out_.pos = vec4(0.0, 0.0, 0.0, 0.0);
        VOut _e38 = out_;
        gl_Position = _e38.pos;
        _vs2fs_location0 = _e38.dist;
        return;
    }
    float _e42 = _group_0_binding_1_vs.adjOff0_;
    float _e46 = _group_0_binding_1_vs.scale0_;
    float _e51 = _group_0_binding_1_vs.scale0_;
    float screenX1_ = (((inst_1.x1_ - _e42) * _e46) - (inst_1.padTop * (_e51 - 1.0)));
    float _e59 = _group_0_binding_1_vs.adjOff0_;
    float _e63 = _group_0_binding_1_vs.scale0_;
    float _e68 = _group_0_binding_1_vs.scale0_;
    float screenX2_ = (((inst_1.x2_ - _e59) * _e63) - (inst_1.padTop * (_e68 - 1.0)));
    float _e76 = _group_0_binding_1_vs.adjOff1_;
    float _e80 = _group_0_binding_1_vs.scale1_;
    float _e85 = _group_0_binding_1_vs.scale1_;
    float screenX3_ = (((inst_1.x3_ - _e76) * _e80) - (inst_1.padBottom * (_e85 - 1.0)));
    float _e93 = _group_0_binding_1_vs.adjOff1_;
    float _e97 = _group_0_binding_1_vs.scale1_;
    float _e102 = _group_0_binding_1_vs.scale1_;
    float screenX4_ = (((inst_1.x4_ - _e93) * _e97) - (inst_1.padBottom * (_e102 - 1.0)));
    uint segs = _group_0_binding_1_vs.edgeSegments;
    uint vertsPerEdge = (segs * 6u);
    uint edgeIdx = (vid / vertsPerEdge);
    uint vidInEdge = (vid % vertsPerEdge);
    uint seg = (vidInEdge / 6u);
    uint vertInSeg = (vidInEdge % 6u);
    float t0_ = (float(seg) / float(segs));
    float t1_ = (float((seg + 1u)) / float(segs));
    switch(vertInSeg) {
        case 0u: {
            t = t0_;
            side = -1.0;
            break;
        }
        case 1u: {
            t = t0_;
            side = 1.0;
            break;
        }
        case 2u: {
            t = t1_;
            side = -1.0;
            break;
        }
        case 3u: {
            t = t1_;
            side = -1.0;
            break;
        }
        case 4u: {
            t = t0_;
            side = 1.0;
            break;
        }
        case 5u: {
            t = t1_;
            side = 1.0;
            break;
        }
        default: {
            t = 0.0;
            side = 0.0;
            break;
        }
    }
    if ((inst_1.isCurve > 0.5)) {
        float _e143 = t;
        float _e144 = t;
        float _e146 = t;
        float s = ((_e143 * _e144) * (3.0 - (2.0 * _e146)));
        edge0_x = mix(screenX1_, screenX4_, s);
        edge1_x = mix(screenX2_, screenX3_, s);
        float _e156 = _group_0_binding_1_vs.height;
        float _e157 = t;
        float _e160 = t;
        float _e164 = t;
        float _e165 = t;
        float _e167 = t;
        y = (_e156 * (((1.5 * _e157) * (1.0 - _e160)) + ((_e164 * _e165) * _e167)));
        float _e171 = t;
        float _e174 = t;
        float sPrime = ((6.0 * _e171) * (1.0 - _e174));
        float _e180 = _group_0_binding_1_vs.height;
        float _e183 = t;
        float _e186 = t;
        float dy = ((_e180 * 1.5) * (1.0 - ((2.0 * _e183) * (1.0 - _e186))));
        float dx = ((edgeIdx == 1u) ? (sPrime * (screenX3_ - screenX2_)) : (sPrime * (screenX4_ - screenX1_)));
        tangent = vec2(dx, dy);
    } else {
        float _e201 = t;
        edge0_x = mix(screenX1_, screenX4_, _e201);
        float _e203 = t;
        edge1_x = mix(screenX2_, screenX3_, _e203);
        float _e205 = t;
        float _e208 = _group_0_binding_1_vs.height;
        y = (_e205 * _e208);
        float dx_1 = ((edgeIdx == 1u) ? (screenX3_ - screenX2_) : (screenX4_ - screenX1_));
        float _e217 = _group_0_binding_1_vs.height;
        tangent = vec2(dx_1, _e217);
    }
    float _e219 = edge0_x;
    float _e220 = edge1_x;
    float edgeX = ((edgeIdx == 1u) ? _e220 : _e219);
    vec2 _e224 = tangent;
    float tangentLen = length(_e224);
    if ((tangentLen > 0.001)) {
        float _e230 = tangent.y;
        float _e233 = tangent.x;
        vec2 rawNormal = (vec2(-(_e230), _e233) / vec2(tangentLen));
        float outwardSign = (((edgeIdx == 0u) ? -1.0 : 1.0) * sign((screenX1_ - screenX2_)));
        normal = (rawNormal * outwardSign);
    } else {
        normal = vec2(0.0, 1.0);
    }
    float _e249 = y;
    vec2 _e251 = normal;
    float _e252 = side;
    pos = (vec2(edgeX, _e249) + ((_e251 * _e252) * 1.0));
    float _e259 = side;
    out_.dist = (_e259 * 1.0);
    vec2 _e262 = pos;
    vec2 _e265 = _group_0_binding_1_vs.resolution;
    vec2 clipSpace = (((_e262 / _e265) * 2.0) - vec2(1.0));
    out_.pos = vec4(clipSpace.x, -(clipSpace.y), 0.0, 1.0);
    VOut _e279 = out_;
    gl_Position = _e279.pos;
    _vs2fs_location0 = _e279.dist;
    return;
}

`

export const EDGE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VOut {
    vec4 pos;
    float dist;
};
smooth in float _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VOut in_ = VOut(gl_FragCoord, _vs2fs_location0);
    float d = abs(in_.dist);
    float aa = fwidth(in_.dist);
    float edgeAlpha = (1.0 - smoothstep((0.5 - (aa * 0.5)), (0.5 + aa), d));
    _fs2p_location0 = vec4(0.0, 0.0, 0.0, (edgeAlpha * 0.4));
    return;
}

`
