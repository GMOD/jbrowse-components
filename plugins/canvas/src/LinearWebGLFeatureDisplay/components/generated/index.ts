// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const RECT_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct RectInstance {
    uvec2 start_end;
    float y;
    float height;
    vec4 color;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    float canvas_width;
    float scroll_y;
    float bp_per_px;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

RectInstance _fetch_RectInstance(int idx) {
    int base = idx * 8;
    RectInstance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.height = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

float snap_to_pixel_x(float clip_x, float canvas_width) {
    float px = (((clip_x + 1.0) * 0.5) * canvas_width);
    return (((floor((px + 0.5)) / canvas_width) * 2.0) - 1.0);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    RectInstance inst = _fetch_RectInstance(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e15 = local;
    if (!(_e15)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e22 = local_1;
    float local_x = (_e22 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e34 = local_2;
    if (!(_e34)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e41 = local_3;
    float local_y = (_e41 ? 0.0 : 1.0);
    uint _e49 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e49);
    uint _e55 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e55);
    vec2 _e57 = hp_split_uint(abs_start);
    vec3 _e60 = _group_0_binding_1_vs.bp_range_x;
    float _e61 = hp_to_clip_x(_e57, _e60);
    float _e64 = _group_0_binding_1_vs.canvas_width;
    float _e65 = snap_to_pixel_x(_e61, _e64);
    vec2 _e66 = hp_split_uint(abs_end);
    vec3 _e69 = _group_0_binding_1_vs.bp_range_x;
    float _e70 = hp_to_clip_x(_e66, _e69);
    float _e73 = _group_0_binding_1_vs.canvas_width;
    float _e74 = snap_to_pixel_x(_e70, _e73);
    float _e77 = _group_0_binding_1_vs.canvas_width;
    float min_width = (4.0 / _e77);
    float final_sx2_ = (((_e74 - _e65) < min_width) ? (_e65 + min_width) : _e74);
    float sx = mix(_e65, final_sx2_, local_x);
    float _e88 = _group_0_binding_1_vs.scroll_y;
    float y_top_px = floor(((inst.y - _e88) + 0.5));
    float y_bot_px = floor(((y_top_px + inst.height) + 0.5));
    float _e100 = _group_0_binding_1_vs.canvas_height;
    float sy_top = (1.0 - ((y_top_px / _e100) * 2.0));
    float _e108 = _group_0_binding_1_vs.canvas_height;
    float sy_bot = (1.0 - ((y_bot_px / _e108) * 2.0));
    float sy = mix(sy_bot, sy_top, local_y);
    out_.position = vec4(sx, sy, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e122 = out_;
    gl_Position = _e122.position;
    _vs2fs_location0 = _e122.color;
    return;
}

`

export const RECT_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

export const LINE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct LineInstance {
    uvec2 start_end;
    float y;
    float _pad;
    vec4 color;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    float canvas_width;
    float scroll_y;
    float bp_per_px;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

LineInstance _fetch_LineInstance(int idx) {
    int base = idx * 8;
    LineInstance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s._pad = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    LineInstance inst = _fetch_LineInstance(int(iid));
    uint v = (vid % 6u);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec3 _e22 = _group_0_binding_1_vs.bp_range_x;
    float _e23 = hp_to_clip_x(_e19, _e22);
    vec2 _e24 = hp_split_uint(abs_end);
    vec3 _e27 = _group_0_binding_1_vs.bp_range_x;
    float _e28 = hp_to_clip_x(_e24, _e27);
    float _e32 = _group_0_binding_1_vs.scroll_y;
    float y_px = (floor(((inst.y - _e32) + 0.5)) + 0.5);
    float _e41 = _group_0_binding_1_vs.canvas_height;
    float cy = (1.0 - ((y_px / _e41) * 2.0));
    float _e49 = _group_0_binding_1_vs.canvas_height;
    float half_px = (1.0 / _e49);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e60 = local;
    if (!(_e60)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e67 = local_1;
    float local_x = (_e67 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e79 = local_2;
    if (!(_e79)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e86 = local_3;
    float local_y = (_e86 ? 0.0 : 1.0);
    float sx = mix(_e23, _e28, local_x);
    float sy = mix((cy - half_px), (cy + half_px), local_y);
    out_.position = vec4(sx, sy, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e101 = out_;
    gl_Position = _e101.position;
    _vs2fs_location0 = _e101.color;
    return;
}

`

export const LINE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

export const CHEVRON_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct ChevronInstance {
    uvec2 start_end;
    float y;
    float direction;
    vec4 color;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    float canvas_width;
    float scroll_y;
    float bp_per_px;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

ChevronInstance _fetch_ChevronInstance(int idx) {
    int base = idx * 8;
    ChevronInstance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.direction = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color = vec4(uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 1) / 4, 0), 0)[(base + 4 + 1) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 2) / 4, 0), 0)[(base + 4 + 2) % 4]), uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4 + 3) / 4, 0), 0)[(base + 4 + 3) % 4]));
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    float sx = 0.0;
    float sy = 0.0;
    ChevronInstance inst = _fetch_ChevronInstance(int(iid));
    int local_chevron_index = int((vid / 12u));
    uint v = (vid % 12u);
    float line_length_bp = float((inst.start_end.y - inst.start_end.x));
    float _e18 = _group_0_binding_1_vs.bp_per_px;
    float line_width_px = (line_length_bp / _e18);
    if (!((inst.direction == 0.0))) {
        local = (line_width_px < (25.0 * 0.5));
    } else {
        local = true;
    }
    bool _e32 = local;
    if (_e32) {
        out_.position = vec4(2.0, 2.0, 0.0, 1.0);
        out_.color = vec4(0.0);
        VertexOutput _e42 = out_;
        gl_Position = _e42.position;
        _vs2fs_location0 = _e42.color;
        return;
    }
    int total_chevrons = max(1, int(floor((line_width_px / 25.0))));
    float bp_spacing = (line_length_bp / float((total_chevrons + 1)));
    float _e55 = _group_0_binding_1_vs.bp_range_x.x;
    float _e59 = _group_0_binding_1_vs.bp_range_x.y;
    uint _e63 = _group_0_binding_1_vs.region_start;
    float viewport_start_bp = (((_e55 + _e59) - float(_e63)) - float(inst.start_end.x));
    float _e73 = _group_0_binding_1_vs.bp_range_x.z;
    float viewport_end_bp = (viewport_start_bp + _e73);
    int first_visible = max(0, (int(floor((viewport_start_bp / bp_spacing))) - 1));
    int last_visible = min((total_chevrons - 1), int(ceil((viewport_end_bp / bp_spacing))));
    int global_chevron_index = (first_visible + local_chevron_index);
    if (!((global_chevron_index < 0))) {
        local_1 = (global_chevron_index > last_visible);
    } else {
        local_1 = true;
    }
    bool _e96 = local_1;
    if (!(_e96)) {
        local_2 = (global_chevron_index >= total_chevrons);
    } else {
        local_2 = true;
    }
    bool _e102 = local_2;
    if (_e102) {
        out_.position = vec4(2.0, 2.0, 0.0, 1.0);
        out_.color = vec4(0.0);
        VertexOutput _e112 = out_;
        gl_Position = _e112.position;
        _vs2fs_location0 = _e112.color;
        return;
    }
    float chevron_offset_bp = (bp_spacing * float((global_chevron_index + 1)));
    uint _e121 = _group_0_binding_1_vs.region_start;
    uint line_start_abs = (inst.start_end.x + _e121);
    vec2 _e123 = hp_split_uint(line_start_abs);
    vec2 split_chevron = vec2(_e123.x, (_e123.y + chevron_offset_bp));
    vec3 _e130 = _group_0_binding_1_vs.bp_range_x;
    float _e131 = hp_to_clip_x(split_chevron, _e130);
    float _e135 = _group_0_binding_1_vs.scroll_y;
    float y_px = (floor(((inst.y - _e135) + 0.5)) + 0.5);
    float _e144 = _group_0_binding_1_vs.canvas_height;
    float cy = (1.0 - ((y_px / _e144) * 2.0));
    float _e152 = _group_0_binding_1_vs.canvas_width;
    float half_w = (4.5 / _e152);
    float _e157 = _group_0_binding_1_vs.canvas_height;
    float half_h = (3.5 / _e157);
    float _e162 = _group_0_binding_1_vs.canvas_height;
    float thickness = (1.0 / _e162);
    float dir = inst.direction;
    bool is_top_arm = (v < 6u);
    uint qv = (v % 6u);
    float tip_x = (_e131 + (half_w * dir));
    float outer_x = (_e131 - (half_w * dir));
    float arm_y = (is_top_arm ? half_h : -(half_h));
    switch(qv) {
        case 0u: {
            sx = outer_x;
            sy = (cy + arm_y);
            break;
        }
        case 1u: {
            sx = tip_x;
            sy = (cy + (thickness * 0.5));
            break;
        }
        case 2u: {
            sx = tip_x;
            sy = (cy - (thickness * 0.5));
            break;
        }
        case 3u: {
            sx = outer_x;
            sy = (cy + arm_y);
            break;
        }
        case 4u: {
            sx = tip_x;
            sy = (cy - (thickness * 0.5));
            break;
        }
        default: {
            sx = outer_x;
            sy = ((cy + arm_y) - (is_top_arm ? -(thickness) : thickness));
            break;
        }
    }
    float _e194 = sx;
    float _e195 = sy;
    out_.position = vec4(_e194, _e195, 0.0, 1.0);
    out_.color = inst.color;
    VertexOutput _e201 = out_;
    gl_Position = _e201.position;
    _vs2fs_location0 = _e201.color;
    return;
}

`

export const CHEVRON_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

export const ARROW_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct ArrowInstance {
    uint x;
    uint _pad0_;
    float y;
    float direction;
    float height;
    float color_r;
    float color_g;
    float color_b;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    float canvas_width;
    float scroll_y;
    float bp_per_px;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

ArrowInstance _fetch_ArrowInstance(int idx) {
    int base = idx * 8;
    ArrowInstance s;
    s.x = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s._pad0_ = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.direction = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.height = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]);
    s.color_r = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 5) / 4, 0), 0)[(base + 5) % 4]);
    s.color_g = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 6) / 4, 0), 0)[(base + 6) % 4]);
    s.color_b = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 7) / 4, 0), 0)[(base + 7) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    ArrowInstance inst = _fetch_ArrowInstance(int(iid));
    uint v = (vid % 9u);
    uint _e10 = _group_0_binding_1_vs.region_start;
    uint abs_x = (inst.x + _e10);
    vec2 _e12 = hp_split_uint(abs_x);
    vec3 _e15 = _group_0_binding_1_vs.bp_range_x;
    float _e16 = hp_to_clip_x(_e12, _e15);
    float _e20 = _group_0_binding_1_vs.scroll_y;
    float y_px = (floor(((inst.y - _e20) + 0.5)) + 0.5);
    float _e29 = _group_0_binding_1_vs.canvas_height;
    float cy = (1.0 - ((y_px / _e29) * 2.0));
    float _e37 = _group_0_binding_1_vs.canvas_width;
    float stem_length = ((7.0 / _e37) * 2.0);
    float _e44 = _group_0_binding_1_vs.canvas_height;
    float stem_half = ((0.5 / _e44) * 2.0);
    float _e51 = _group_0_binding_1_vs.canvas_height;
    float head_half = ((2.5 / _e51) * 2.0);
    float dir = inst.direction;
    if ((v < 6u)) {
        if (!((v == 0u))) {
            local = (v == 2u);
        } else {
            local = true;
        }
        bool _e69 = local;
        if (!(_e69)) {
            local_1 = (v == 3u);
        } else {
            local_1 = true;
        }
        bool _e76 = local_1;
        float local_x = (_e76 ? 0.0 : 1.0);
        if (!((v == 0u))) {
            local_2 = (v == 1u);
        } else {
            local_2 = true;
        }
        bool _e88 = local_2;
        if (!(_e88)) {
            local_3 = (v == 4u);
        } else {
            local_3 = true;
        }
        bool _e95 = local_3;
        float local_y = (_e95 ? -1.0 : 1.0);
        sx = (_e16 + (((local_x * stem_length) * 0.5) * dir));
        sy = (cy + (local_y * stem_half));
    } else {
        uint hvid = (v - 6u);
        if ((hvid == 0u)) {
            sx = (_e16 + ((stem_length * 0.5) * dir));
            sy = (cy + head_half);
        } else {
            if ((hvid == 1u)) {
                sx = (_e16 + ((stem_length * 0.5) * dir));
                sy = (cy - head_half);
            } else {
                sx = (_e16 + (stem_length * dir));
                sy = cy;
            }
        }
    }
    float _e126 = sx;
    float _e127 = sy;
    out_.position = vec4(_e126, _e127, 0.0, 1.0);
    out_.color = vec4(inst.color_r, inst.color_g, inst.color_b, 1.0);
    VertexOutput _e137 = out_;
    gl_Position = _e137.position;
    _vs2fs_location0 = _e137.color;
    return;
}

`

export const ARROW_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`
