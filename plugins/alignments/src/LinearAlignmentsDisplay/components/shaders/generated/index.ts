// Auto-generated by compile-shaders.ts from WGSL sources
// Do not edit manually - edit the WGSL sources in wgsl/ instead
// Regenerate: pnpm compile-shaders

export const READ_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct ReadInst {
    uint start_off;
    uint end_off;
    uint y;
    uint flags;
    uint mapq;
    float insert_size;
    uint pair_orient;
    int strand;
    float tag_r;
    float tag_g;
    float tag_b;
    uint chain_supp;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
    vec2 local_pos;
    vec2 feat_size_px;
    float edge_flags;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ReadInst _fetch_ReadInst(int idx) {
    int base = idx * 12;
    ReadInst s;
    s.start_off = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.end_off = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.flags = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    s.mapq = texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4];
    s.insert_size = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 5) / 4, 0), 0)[(base + 5) % 4]);
    s.pair_orient = texelFetch(u_instanceData, ivec2((base + 6) / 4, 0), 0)[(base + 6) % 4];
    s.strand = int(texelFetch(u_instanceData, ivec2((base + 7) / 4, 0), 0)[(base + 7) % 4]);
    s.tag_r = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 8) / 4, 0), 0)[(base + 8) % 4]);
    s.tag_g = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 9) / 4, 0), 0)[(base + 9) % 4]);
    s.tag_b = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 10) / 4, 0), 0)[(base + 10) % 4]);
    s.chain_supp = texelFetch(u_instanceData, ivec2((base + 11) / 4, 0), 0)[(base + 11) % 4];
    return s;
}

smooth out vec4 _vs2fs_location0;
smooth out vec2 _vs2fs_location1;
smooth out vec2 _vs2fs_location2;
smooth out float _vs2fs_location3;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

uint uu(uint i_1) {
    uint _e8 = _group_0_binding_1_vs[(i_1 / 4u)][(i_1 % 4u)];
    return _e8;
}

int ui(uint i_2) {
    uint _e8 = _group_0_binding_1_vs[(i_2 / 4u)][(i_2 % 4u)];
    return int(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

vec3 bp_range_1() {
    float _e1 = uf(0u);
    float _e3 = uf(1u);
    float _e5 = uf(2u);
    return vec3(_e1, _e3, _e5);
}

uint region_start() {
    uint _e1 = uu(3u);
    return _e1;
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot = (y_top + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top * px2clip)), (top_clip - (y_bot * px2clip)));
}

vec3 normal_color() {
    vec3 _e1 = color3_(41u);
    return _e1;
}

vec3 strand_color(int s) {
    if ((s > 0)) {
        vec3 _e4 = color3_(32u);
        return _e4;
    }
    if ((s < 0)) {
        vec3 _e8 = color3_(35u);
        return _e8;
    }
    vec3 _e10 = color3_(38u);
    return _e10;
}

vec3 mapq_color(uint mapq) {
    vec3 rgb = vec3(0.0);
    float h = (float(mapq) / 360.0);
    float hp = (h * 6.0);
    float x = (0.5 * (1.0 - abs(((hp - 2.0 * trunc(hp / 2.0)) - 1.0))));
    if ((hp < 1.0)) {
        rgb = vec3(0.5, x, 0.0);
    } else {
        if ((hp < 2.0)) {
            rgb = vec3(x, 0.5, 0.0);
        } else {
            if ((hp < 3.0)) {
                rgb = vec3(0.0, 0.5, x);
            } else {
                if ((hp < 4.0)) {
                    rgb = vec3(0.0, x, 0.5);
                } else {
                    if ((hp < 5.0)) {
                        rgb = vec3(x, 0.0, 0.5);
                    } else {
                        rgb = vec3(0.5, 0.0, x);
                    }
                }
            }
        }
    }
    vec3 _e39 = rgb;
    return (_e39 + vec3(0.25));
}

vec3 insert_size_color(float is) {
    float _e2 = uf(21u);
    if ((is > _e2)) {
        vec3 _e5 = color3_(89u);
        return _e5;
    }
    float _e7 = uf(22u);
    if ((is < _e7)) {
        vec3 _e10 = color3_(92u);
        return _e10;
    }
    vec3 _e12 = color3_(41u);
    return _e12;
}

vec3 first_of_pair_color(uint flags, int s_1) {
    bool is_first = ((flags & 64u) != 0u);
    int eff = (!(is_first) ? -(s_1) : s_1);
    if ((eff > 0)) {
        vec3 _e12 = color3_(32u);
        return _e12;
    }
    if ((eff < 0)) {
        vec3 _e16 = color3_(35u);
        return _e16;
    }
    vec3 _e18 = color3_(38u);
    return _e18;
}

vec3 pair_orient_color(uint po) {
    if ((po == 1u)) {
        vec3 _e4 = color3_(41u);
        return _e4;
    }
    if ((po == 2u)) {
        vec3 _e8 = color3_(44u);
        return _e8;
    }
    if ((po == 3u)) {
        vec3 _e12 = color3_(47u);
        return _e12;
    }
    if ((po == 4u)) {
        vec3 _e16 = color3_(50u);
        return _e16;
    }
    vec3 _e18 = color3_(38u);
    return _e18;
}

vec3 is_and_orient_color(float is_1, uint po_1) {
    if ((po_1 == 2u)) {
        vec3 _e5 = color3_(44u);
        return _e5;
    }
    if ((po_1 == 3u)) {
        vec3 _e9 = color3_(47u);
        return _e9;
    }
    if ((po_1 == 4u)) {
        vec3 _e13 = color3_(50u);
        return _e13;
    }
    vec3 _e14 = insert_size_color(is_1);
    return _e14;
}

vec3 modifications_color(uint flags_1) {
    if (((flags_1 & 16u) != 0u)) {
        vec3 _e6 = color3_(86u);
        return _e6;
    }
    vec3 _e8 = color3_(83u);
    return _e8;
}

vec3 get_read_color(ReadInst inst) {
    bool local_14 = false;
    int _e2 = ui(11u);
    int _e4 = ui(14u);
    if ((_e4 == 1)) {
        local_14 = (inst.chain_supp > 0u);
    } else {
        local_14 = false;
    }
    bool _e13 = local_14;
    if (_e13) {
        vec3 _e15 = color3_(95u);
        return _e15;
    }
    if ((_e2 == 0)) {
        vec3 _e18 = normal_color();
        return _e18;
    }
    if ((_e2 == 1)) {
        vec3 _e22 = strand_color(inst.strand);
        return _e22;
    }
    if ((_e2 == 2)) {
        vec3 _e26 = mapq_color(inst.mapq);
        return _e26;
    }
    if ((_e2 == 3)) {
        vec3 _e30 = insert_size_color(inst.insert_size);
        return _e30;
    }
    if ((_e2 == 4)) {
        vec3 _e35 = first_of_pair_color(inst.flags, inst.strand);
        return _e35;
    }
    if ((_e2 == 5)) {
        vec3 _e39 = pair_orient_color(inst.pair_orient);
        return _e39;
    }
    if ((_e2 == 6)) {
        vec3 _e44 = is_and_orient_color(inst.insert_size, inst.pair_orient);
        return _e44;
    }
    if ((_e2 == 7)) {
        vec3 _e48 = modifications_color(inst.flags);
        return _e48;
    }
    if ((_e2 == 8)) {
        return vec3(inst.tag_r, inst.tag_g, inst.tag_b);
    }
    return vec3(0.6);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0), vec2(0.0), vec2(0.0), 0.0);
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float sx = 0.0;
    float sy = 0.0;
    float lx = 0.0;
    float ly = 0.0;
    float ef = 0.0;
    bool local_4 = false;
    bool local_5 = false;
    bool local_6 = false;
    bool local_7 = false;
    bool local_8 = false;
    bool local_9 = false;
    bool local_10 = false;
    bool local_11 = false;
    bool local_12 = false;
    bool local_13 = false;
    ReadInst inst_1 = _fetch_ReadInst(int(iid));
    int _e7 = ui(13u);
    int _e9 = ui(12u);
    if ((_e7 == 1)) {
        if (!((_e9 < 0))) {
            local_1 = (uint(_e9) != iid);
        } else {
            local_1 = true;
        }
        bool _e22 = local_1;
        local = _e22;
    } else {
        local = false;
    }
    bool _e24 = local;
    if (_e24) {
        out_.position = vec4(0.0);
        out_.color = vec4(0.0);
        VertexOutput _e31 = out_;
        gl_Position = _e31.position;
        _vs2fs_location0 = _e31.color;
        _vs2fs_location1 = _e31.local_pos;
        _vs2fs_location2 = _e31.feat_size_px;
        _vs2fs_location3 = _e31.edge_flags;
        return;
    }
    uint v = (vid % 9u);
    uint _e35 = region_start();
    uint abs_start = (inst_1.start_off + _e35);
    uint _e38 = region_start();
    uint abs_end = (inst_1.end_off + _e38);
    vec2 _e40 = hp_split_uint(abs_start);
    vec3 _e41 = bp_range_1();
    float _e42 = hp_to_clip_x(_e40, _e41);
    vec2 _e43 = hp_split_uint(abs_end);
    vec3 _e44 = bp_range_1();
    float _e45 = hp_to_clip_x(_e43, _e44);
    vec2 _e48 = pileup_y(float(inst_1.y));
    float sy_top = _e48.x;
    float sy_bot = _e48.y;
    float sy_mid = ((sy_top + sy_bot) * 0.5);
    float _e54 = canvas_width();
    float chevron_clip = ((8.0 / _e54) * 2.0);
    float _e60 = uf(2u);
    float _e61 = canvas_width();
    float bp_per_px = (_e60 / _e61);
    int _e64 = ui(14u);
    if (!((_e64 == 1))) {
        local_2 = (bp_per_px < 10.0);
    } else {
        local_2 = true;
    }
    bool _e73 = local_2;
    if (_e73) {
        float _e76 = feature_height();
        local_3 = (_e76 >= 3.0);
    } else {
        local_3 = false;
    }
    bool show_chev = local_3;
    float _e82 = canvas_width();
    float feat_w_px = (((_e45 - _e42) * _e82) * 0.5);
    float _e87 = feature_height();
    out_.feat_size_px = vec2(feat_w_px, _e87);
    if ((_e7 == 1)) {
        if (!((v == 0u))) {
            local_4 = (v == 2u);
        } else {
            local_4 = true;
        }
        bool _e105 = local_4;
        if (!(_e105)) {
            local_5 = (v == 3u);
        } else {
            local_5 = true;
        }
        bool _e112 = local_5;
        lx = (_e112 ? 0.0 : 1.0);
        if (!((v == 0u))) {
            local_6 = (v == 1u);
        } else {
            local_6 = true;
        }
        bool _e124 = local_6;
        if (!(_e124)) {
            local_7 = (v == 4u);
        } else {
            local_7 = true;
        }
        bool _e131 = local_7;
        ly = (_e131 ? 0.0 : 1.0);
        float _e135 = lx;
        sx = mix(_e42, _e45, _e135);
        float _e137 = ly;
        sy = mix(sy_bot, sy_top, _e137);
        if ((v >= 6u)) {
            sx = _e42;
            sy = sy_top;
            lx = 0.5;
            ly = 0.5;
        }
    } else {
        if ((v < 6u)) {
            if (!((v == 0u))) {
                local_8 = (v == 2u);
            } else {
                local_8 = true;
            }
            bool _e153 = local_8;
            if (!(_e153)) {
                local_9 = (v == 3u);
            } else {
                local_9 = true;
            }
            bool _e160 = local_9;
            lx = (_e160 ? 0.0 : 1.0);
            if (!((v == 0u))) {
                local_10 = (v == 1u);
            } else {
                local_10 = true;
            }
            bool _e172 = local_10;
            if (!(_e172)) {
                local_11 = (v == 4u);
            } else {
                local_11 = true;
            }
            bool _e179 = local_11;
            ly = (_e179 ? 0.0 : 1.0);
            float _e183 = lx;
            sx = mix(_e42, _e45, _e183);
            float _e185 = ly;
            sy = mix(sy_bot, sy_top, _e185);
            if (show_chev) {
                local_12 = (inst_1.strand > 0);
            } else {
                local_12 = false;
            }
            bool _e193 = local_12;
            if (_e193) {
                ef = 1.0;
            } else {
                if (show_chev) {
                    local_13 = (inst_1.strand < 0);
                } else {
                    local_13 = false;
                }
                bool _e201 = local_13;
                if (_e201) {
                    ef = -1.0;
                }
            }
        } else {
            if (show_chev) {
                ef = 2.0;
                float _e205 = feature_height();
                float half_h = (_e205 * 0.5);
                float _e208 = feature_height();
                float alt = ((8.0 * _e208) / sqrt(((half_h * half_h) + (8.0 * 8.0))));
                if ((inst_1.strand > 0)) {
                    if ((v == 6u)) {
                        sx = _e45;
                        sy = sy_top;
                        lx = 0.0;
                        ly = alt;
                    } else {
                        if ((v == 7u)) {
                            sx = _e45;
                            sy = sy_bot;
                            lx = alt;
                            ly = 0.0;
                        } else {
                            sx = (_e45 + chevron_clip);
                            sy = sy_mid;
                            lx = 0.0;
                            ly = 0.0;
                        }
                    }
                } else {
                    if ((inst_1.strand < 0)) {
                        if ((v == 6u)) {
                            sx = _e42;
                            sy = sy_top;
                            lx = 0.0;
                            ly = alt;
                        } else {
                            if ((v == 7u)) {
                                sx = (_e42 - chevron_clip);
                                sy = sy_mid;
                                lx = 0.0;
                                ly = 0.0;
                            } else {
                                sx = _e42;
                                sy = sy_bot;
                                lx = alt;
                                ly = 0.0;
                            }
                        }
                    } else {
                        lx = 999.0;
                        ly = 999.0;
                        sx = _e42;
                        sy = sy_top;
                    }
                }
            } else {
                lx = 0.5;
                ly = 0.5;
                sx = _e42;
                sy = sy_top;
            }
        }
    }
    float _e244 = lx;
    float _e245 = ly;
    out_.local_pos = vec2(_e244, _e245);
    float _e248 = ef;
    out_.edge_flags = _e248;
    float _e250 = sx;
    float _e251 = sy;
    out_.position = vec4(_e250, _e251, 0.0, 1.0);
    if ((_e7 == 1)) {
        out_.color = vec4(0.0, 0.0, 0.0, 0.4);
    } else {
        vec3 _e264 = get_read_color(inst_1);
        out_.color = vec4(_e264, 1.0);
    }
    VertexOutput _e267 = out_;
    gl_Position = _e267.position;
    _vs2fs_location0 = _e267.color;
    _vs2fs_location1 = _e267.local_pos;
    _vs2fs_location2 = _e267.feat_size_px;
    _vs2fs_location3 = _e267.edge_flags;
    return;
}

`

export const READ_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
    vec2 local_pos;
    vec2 feat_size_px;
    float edge_flags;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_4_block_0Fragment { uvec4 _group_0_binding_1_fs[40]; };

smooth in vec4 _vs2fs_location0;
smooth in vec2 _vs2fs_location1;
smooth in vec2 _vs2fs_location2;
smooth in float _vs2fs_location3;
out vec4 _fs2p_location0;

int ui(uint i) {
    uint _e8 = _group_0_binding_1_fs[(i / 4u)][(i % 4u)];
    return int(_e8);
}

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0, _vs2fs_location1, _vs2fs_location2, _vs2fs_location3);
    float edge_dist = 0.0;
    float dx_r = 0.0;
    float dx_ll = 0.0;
    bool local = false;
    bool local_1 = false;
    int _e2 = ui(15u);
    if ((_e2 == 1)) {
        if ((in_.edge_flags > 1.5)) {
            edge_dist = min(in_.local_pos.x, in_.local_pos.y);
        } else {
            float dx_l = (in_.local_pos.x * in_.feat_size_px.x);
            dx_r = ((1.0 - in_.local_pos.x) * in_.feat_size_px.x);
            if ((in_.edge_flags > 0.5)) {
                dx_r = 999.0;
            }
            dx_ll = dx_l;
            if ((in_.edge_flags < -0.5)) {
                dx_ll = 999.0;
            }
            float dy = (min(in_.local_pos.y, (1.0 - in_.local_pos.y)) * in_.feat_size_px.y);
            float _e46 = dx_ll;
            float _e47 = dx_r;
            edge_dist = min(min(_e46, _e47), dy);
        }
        float _e50 = edge_dist;
        if ((_e50 < 1.0)) {
            local = (in_.feat_size_px.x > 4.0);
        } else {
            local = false;
        }
        bool _e60 = local;
        if (_e60) {
            local_1 = (in_.feat_size_px.y > 4.0);
        } else {
            local_1 = false;
        }
        bool _e68 = local_1;
        if (_e68) {
            _fs2p_location0 = vec4((in_.color.xyz * 0.7), in_.color.w);
            return;
        }
    }
    _fs2p_location0 = in_.color;
    return;
}

`

export const GAP_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct GapInst {
    uint start_off;
    uint end_off;
    uint y;
    uint gap_type;
    float frequency;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

GapInst _fetch_GapInst(int idx) {
    int base = idx * 5;
    GapInst s;
    s.start_off = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.end_off = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.gap_type = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    s.frequency = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

int ui(uint i_1) {
    uint _e8 = _group_0_binding_1_vs[(i_1 / 4u)][(i_1 % 4u)];
    return int(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top_1 = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot_1 = (y_top_1 + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top_1 * px2clip)), (top_clip - (y_bot_1 * px2clip)));
}

vec2 cigar_domain() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float cigar_domain_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    float y_top = 0.0;
    float y_bot = 0.0;
    bool local_5 = false;
    float alpha = 1.0;
    bool local_6 = false;
    GapInst inst = _fetch_GapInst(int(iid));
    int _e7 = ui(23u);
    if ((_e7 == 1)) {
        local = (inst.gap_type == 0u);
    } else {
        local = false;
    }
    bool _e16 = local;
    if (_e16) {
        out_.position = vec4(0.0);
        out_.color = vec4(0.0);
        VertexOutput _e23 = out_;
        gl_Position = _e23.position;
        _vs2fs_location0 = _e23.color;
        return;
    }
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local_1 = (v == 2u);
    } else {
        local_1 = true;
    }
    bool _e34 = local_1;
    if (!(_e34)) {
        local_2 = (v == 3u);
    } else {
        local_2 = true;
    }
    bool _e41 = local_2;
    float lx = (_e41 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_3 = (v == 1u);
    } else {
        local_3 = true;
    }
    bool _e53 = local_3;
    if (!(_e53)) {
        local_4 = (v == 4u);
    } else {
        local_4 = true;
    }
    bool _e60 = local_4;
    float ly = (_e60 ? 0.0 : 1.0);
    float _e64 = cigar_domain_len();
    vec2 _e65 = cigar_domain();
    float sx1_ = ((((float(inst.start_off) - _e65.x) / _e64) * 2.0) - 1.0);
    float sx2_ = ((((float(inst.end_off) - _e65.x) / _e64) * 2.0) - 1.0);
    vec2 _e86 = pileup_y(float(inst.y));
    y_top = _e86.x;
    y_bot = _e86.y;
    if ((_e7 == 0)) {
        local_5 = (inst.gap_type == 1u);
    } else {
        local_5 = false;
    }
    bool _e99 = local_5;
    if (_e99) {
        float _e100 = y_top;
        float _e101 = y_bot;
        float mid = ((_e100 + _e101) * 0.5);
        float _e105 = canvas_height();
        float one_px = (2.0 / _e105);
        y_top = mid;
        y_bot = (mid - one_px);
    }
    float sx = mix(sx1_, sx2_, lx);
    float _e110 = y_bot;
    float _e111 = y_top;
    float sy = mix(_e110, _e111, ly);
    out_.position = vec4(sx, sy, 0.0, 1.0);
    if ((inst.gap_type == 0u)) {
        float _e122 = canvas_width();
        float px_per_bp = (_e122 / _e64);
        if ((px_per_bp < 1.0)) {
            local_6 = (inst.frequency < 0.1);
        } else {
            local_6 = false;
        }
        bool _e132 = local_6;
        if (_e132) {
            alpha = px_per_bp;
        }
    }
    vec3 _e134 = color3_(71u);
    vec3 _e136 = color3_(68u);
    vec3 c = ((inst.gap_type == 0u) ? _e136 : _e134);
    float _e142 = alpha;
    out_.color = vec4(c, _e142);
    VertexOutput _e144 = out_;
    gl_Position = _e144.position;
    _vs2fs_location0 = _e144.color;
    return;
}

`

export const GAP_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const MISMATCH_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct MismatchInst {
    uint position;
    uint y;
    uint base;
    float frequency;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

MismatchInst _fetch_MismatchInst(int idx) {
    int base = idx * 4;
    MismatchInst s;
    s.position = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.base = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.frequency = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot = (y_top + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top * px2clip)), (top_clip - (y_bot * px2clip)));
}

vec2 cigar_domain() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float cigar_domain_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float alpha = 1.0;
    bool local_4 = false;
    float px1_ = 0.0;
    float px2_ = 0.0;
    vec3 c = vec3(0.0);
    bool local_5 = false;
    bool local_6 = false;
    bool local_7 = false;
    bool local_8 = false;
    MismatchInst inst = _fetch_MismatchInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = cigar_domain_len();
    vec2 _e47 = cigar_domain();
    float pos = float(inst.position);
    float _e50 = canvas_width();
    float px_per_bp = (_e50 / _e46);
    if ((px_per_bp < 1.0)) {
        local_4 = (inst.frequency < 0.1);
    } else {
        local_4 = false;
    }
    bool _e62 = local_4;
    if (_e62) {
        alpha = px_per_bp;
    }
    float _e63 = alpha;
    if ((_e63 <= 0.0)) {
        out_.position = vec4(0.0);
        out_.color = vec4(0.0);
        VertexOutput _e72 = out_;
        gl_Position = _e72.position;
        _vs2fs_location0 = _e72.color;
        return;
    }
    float _e76 = canvas_width();
    px1_ = (((pos - _e47.x) / _e46) * _e76);
    float _e84 = canvas_width();
    px2_ = ((((pos + 1.0) - _e47.x) / _e46) * _e84);
    float _e87 = px1_;
    px1_ = floor(_e87);
    float _e89 = px1_;
    float _e92 = px2_;
    px2_ = max((_e89 + 1.0), floor(_e92));
    float _e95 = px1_;
    float _e96 = canvas_width();
    float sx1_ = (((_e95 / _e96) * 2.0) - 1.0);
    float _e102 = px2_;
    float _e103 = canvas_width();
    float sx2_ = (((_e102 / _e103) * 2.0) - 1.0);
    float sx = mix(sx1_, sx2_, lx);
    vec2 _e112 = pileup_y(float(inst.y));
    float sy = mix(_e112.y, _e112.x, ly);
    out_.position = vec4(sx, sy, 0.0, 1.0);
    uint b = inst.base;
    if (!((b == 65u))) {
        local_5 = (b == 97u);
    } else {
        local_5 = true;
    }
    bool _e130 = local_5;
    if (_e130) {
        vec3 _e132 = color3_(53u);
        c = _e132;
    } else {
        if (!((b == 67u))) {
            local_6 = (b == 99u);
        } else {
            local_6 = true;
        }
        bool _e141 = local_6;
        if (_e141) {
            vec3 _e143 = color3_(56u);
            c = _e143;
        } else {
            if (!((b == 71u))) {
                local_7 = (b == 103u);
            } else {
                local_7 = true;
            }
            bool _e152 = local_7;
            if (_e152) {
                vec3 _e154 = color3_(59u);
                c = _e154;
            } else {
                if (!((b == 84u))) {
                    local_8 = (b == 116u);
                } else {
                    local_8 = true;
                }
                bool _e163 = local_8;
                if (_e163) {
                    vec3 _e165 = color3_(62u);
                    c = _e165;
                } else {
                    c = vec3(0.5);
                }
            }
        }
    }
    vec3 _e169 = c;
    float _e170 = alpha;
    out_.color = vec4(_e169, _e170);
    VertexOutput _e172 = out_;
    gl_Position = _e172.position;
    _vs2fs_location0 = _e172.color;
    return;
}

`

export const MISMATCH_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const INSERTION_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct InsertionInst {
    uint position;
    uint y;
    uint length_;
    float frequency;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

InsertionInst _fetch_InsertionInst(int idx) {
    int base = idx * 4;
    InsertionInst s;
    s.position = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.length_ = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.frequency = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot = (y_top + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top * px2clip)), (top_clip - (y_bot * px2clip)));
}

vec2 cigar_domain() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float cigar_domain_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

float text_width(uint num) {
    if ((num < 10u)) {
        return (6.0 + 10.0);
    }
    if ((num < 100u)) {
        return ((6.0 * 2.0) + 10.0);
    }
    if ((num < 1000u)) {
        return ((6.0 * 3.0) + 10.0);
    }
    if ((num < 10000u)) {
        return ((6.0 * 4.0) + 10.0);
    }
    return ((6.0 * 5.0) + 10.0);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    bool local_5 = false;
    float rect_w = 0.0;
    float x1_ = 0.0;
    float x2_ = 0.0;
    float y1_ = 0.0;
    float y2_ = 0.0;
    bool local_6 = false;
    bool local_7 = false;
    float alpha = 1.0;
    bool local_8 = false;
    bool local_9 = false;
    InsertionInst inst = _fetch_InsertionInst(int(iid));
    uint rect_idx = (vid / 6u);
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e18 = local;
    if (!(_e18)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e25 = local_1;
    float lx = (_e25 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e37 = local_2;
    if (!(_e37)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e44 = local_3;
    float ly = (_e44 ? 0.0 : 1.0);
    float _e48 = cigar_domain_len();
    vec2 _e49 = cigar_domain();
    float pos = float(inst.position);
    float _e52 = canvas_width();
    float bp_per_px = (_e48 / _e52);
    float px_per_bp = (1.0 / bp_per_px);
    float cx = ((((pos - _e49.x) / _e48) * 2.0) - 1.0);
    bool is_long = (inst.length_ >= 10u);
    float ins_w_px = (float(inst.length_) * px_per_bp);
    if ((ins_w_px >= 15.0)) {
        local_4 = (px_per_bp >= 6.5);
    } else {
        local_4 = false;
    }
    bool can_text = local_4;
    if (is_long) {
        local_5 = can_text;
    } else {
        local_5 = false;
    }
    bool is_large = local_5;
    if (is_large) {
        float _e83 = text_width(inst.length_);
        rect_w = _e83;
    } else {
        if (is_long) {
            rect_w = min(5.0, (ins_w_px / 3.0));
        } else {
            rect_w = min(px_per_bp, 1.0);
        }
    }
    float _e90 = canvas_width();
    float one_px = (2.0 / _e90);
    float _e93 = rect_w;
    float _e96 = canvas_width();
    float rect_w_clip = ((_e93 * 2.0) / _e96);
    float tick_w_clip = (one_px * 3.0);
    vec2 _e102 = pileup_y(float(inst.y));
    float sy_top = _e102.x;
    float sy_bot = _e102.y;
    if ((rect_idx == 0u)) {
        x1_ = (cx - (rect_w_clip * 0.5));
        x2_ = (cx + (rect_w_clip * 0.5));
        y1_ = sy_bot;
        y2_ = sy_top;
    } else {
        if ((rect_idx == 1u)) {
            if (!(is_long)) {
                local_6 = (px_per_bp < 0.5);
            } else {
                local_6 = true;
            }
            bool _e125 = local_6;
            if (_e125) {
                x1_ = cx;
                x2_ = cx;
                y1_ = sy_top;
                y2_ = sy_top;
            } else {
                x1_ = (cx - (tick_w_clip * 0.5));
                x2_ = (cx + (tick_w_clip * 0.5));
                float _e132 = canvas_height();
                float th = ((1.0 / _e132) * 2.0);
                y1_ = sy_top;
                y2_ = (sy_top + th);
            }
        } else {
            if (!(is_long)) {
                local_7 = (px_per_bp < 0.5);
            } else {
                local_7 = true;
            }
            bool _e144 = local_7;
            if (_e144) {
                x1_ = cx;
                x2_ = cx;
                y1_ = sy_bot;
                y2_ = sy_bot;
            } else {
                x1_ = (cx - (tick_w_clip * 0.5));
                x2_ = (cx + (tick_w_clip * 0.5));
                float _e151 = canvas_height();
                float th_1 = ((1.0 / _e151) * 2.0);
                y1_ = (sy_bot - th_1);
                y2_ = sy_bot;
            }
        }
    }
    float _e157 = x1_;
    float _e158 = x2_;
    float sx = mix(_e157, _e158, lx);
    float _e160 = y1_;
    float _e161 = y2_;
    float sy = mix(_e160, _e161, ly);
    if (!(is_long)) {
        local_8 = (px_per_bp < 1.0);
    } else {
        local_8 = false;
    }
    bool _e171 = local_8;
    if (_e171) {
        local_9 = (inst.frequency < 0.1);
    } else {
        local_9 = false;
    }
    bool _e178 = local_9;
    if (_e178) {
        alpha = px_per_bp;
    }
    out_.position = vec4(sx, sy, 0.0, 1.0);
    vec3 _e185 = color3_(65u);
    float _e186 = alpha;
    out_.color = vec4(_e185, _e186);
    VertexOutput _e188 = out_;
    gl_Position = _e188.position;
    _vs2fs_location0 = _e188.color;
    return;
}

`

export const INSERTION_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const SOFTCLIP_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct ClipInst {
    uint position;
    uint y;
    uint length_;
    float frequency;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ClipInst _fetch_ClipInst(int idx) {
    int base = idx * 4;
    ClipInst s;
    s.position = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.length_ = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.frequency = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot = (y_top + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top * px2clip)), (top_clip - (y_bot * px2clip)));
}

vec2 cigar_domain() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float cigar_domain_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float alpha = 1.0;
    bool local_4 = false;
    float sx1_ = 0.0;
    float sx2_ = 0.0;
    ClipInst inst = _fetch_ClipInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = cigar_domain_len();
    vec2 _e47 = cigar_domain();
    float pos = float(inst.position);
    float _e50 = canvas_width();
    float px_per_bp = (_e50 / _e46);
    if ((px_per_bp < 1.0)) {
        local_4 = (inst.frequency < 0.1);
    } else {
        local_4 = false;
    }
    bool _e62 = local_4;
    if (_e62) {
        alpha = px_per_bp;
    }
    float _e63 = alpha;
    if ((_e63 <= 0.0)) {
        out_.position = vec4(0.0);
        out_.color = vec4(0.0);
        VertexOutput _e72 = out_;
        gl_Position = _e72.position;
        _vs2fs_location0 = _e72.color;
        return;
    }
    float bp_per_px = (1.0 / px_per_bp);
    float bar_w = max(bp_per_px, min((2.0 * bp_per_px), 1.0));
    sx1_ = (((((pos - (bar_w * 0.5)) - _e47.x) / _e46) * 2.0) - 1.0);
    sx2_ = (((((pos + (bar_w * 0.5)) - _e47.x) / _e46) * 2.0) - 1.0);
    float _e102 = canvas_width();
    float min_w = (2.0 / _e102);
    float _e105 = sx2_;
    float _e106 = sx1_;
    if (((_e105 - _e106) < min_w)) {
        float _e109 = sx1_;
        float _e110 = sx2_;
        float mid = ((_e109 + _e110) * 0.5);
        sx1_ = (mid - (min_w * 0.5));
        sx2_ = (mid + (min_w * 0.5));
    }
    vec2 _e122 = pileup_y(float(inst.y));
    float _e124 = sx1_;
    float _e125 = sx2_;
    out_.position = vec4(mix(_e124, _e125, lx), mix(_e122.y, _e122.x, ly), 0.0, 1.0);
    vec3 _e135 = color3_(74u);
    float _e136 = alpha;
    out_.color = vec4(_e135, _e136);
    VertexOutput _e138 = out_;
    gl_Position = _e138.position;
    _vs2fs_location0 = _e138.color;
    return;
}

`

export const SOFTCLIP_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const HARDCLIP_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct ClipInst {
    uint position;
    uint y;
    uint length_;
    float frequency;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ClipInst _fetch_ClipInst(int idx) {
    int base = idx * 4;
    ClipInst s;
    s.position = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.length_ = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s.frequency = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot = (y_top + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top * px2clip)), (top_clip - (y_bot * px2clip)));
}

vec2 cigar_domain() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float cigar_domain_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float alpha = 1.0;
    bool local_4 = false;
    float sx1_ = 0.0;
    float sx2_ = 0.0;
    ClipInst inst = _fetch_ClipInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = cigar_domain_len();
    vec2 _e47 = cigar_domain();
    float pos = float(inst.position);
    float _e50 = canvas_width();
    float px_per_bp = (_e50 / _e46);
    if ((px_per_bp < 1.0)) {
        local_4 = (inst.frequency < 0.1);
    } else {
        local_4 = false;
    }
    bool _e62 = local_4;
    if (_e62) {
        alpha = px_per_bp;
    }
    float _e63 = alpha;
    if ((_e63 <= 0.0)) {
        out_.position = vec4(0.0);
        out_.color = vec4(0.0);
        VertexOutput _e72 = out_;
        gl_Position = _e72.position;
        _vs2fs_location0 = _e72.color;
        return;
    }
    float bp_per_px = (1.0 / px_per_bp);
    float bar_w = max(bp_per_px, min((2.0 * bp_per_px), 1.0));
    sx1_ = (((((pos - (bar_w * 0.5)) - _e47.x) / _e46) * 2.0) - 1.0);
    sx2_ = (((((pos + (bar_w * 0.5)) - _e47.x) / _e46) * 2.0) - 1.0);
    float _e102 = canvas_width();
    float min_w = (2.0 / _e102);
    float _e105 = sx2_;
    float _e106 = sx1_;
    if (((_e105 - _e106) < min_w)) {
        float _e109 = sx1_;
        float _e110 = sx2_;
        float mid = ((_e109 + _e110) * 0.5);
        sx1_ = (mid - (min_w * 0.5));
        sx2_ = (mid + (min_w * 0.5));
    }
    vec2 _e122 = pileup_y(float(inst.y));
    float _e124 = sx1_;
    float _e125 = sx2_;
    out_.position = vec4(mix(_e124, _e125, lx), mix(_e122.y, _e122.x, ly), 0.0, 1.0);
    vec3 _e135 = color3_(77u);
    float _e136 = alpha;
    out_.color = vec4(_e135, _e136);
    VertexOutput _e138 = out_;
    gl_Position = _e138.position;
    _vs2fs_location0 = _e138.color;
    return;
}

`

export const HARDCLIP_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const MODIFICATION_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct ModInst {
    uint position;
    uint y;
    uint packed_color;
    uint _pad;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_4_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ModInst _fetch_ModInst(int idx) {
    int base = idx * 4;
    ModInst s;
    s.position = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.y = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.packed_color = texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4];
    s._pad = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

float range_y0_() {
    float _e1 = uf(4u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

vec2 pileup_y(float row) {
    float _e1 = feature_height();
    float _e2 = feature_spacing();
    float row_h = (_e1 + _e2);
    float _e5 = range_y0_();
    float y_top = ((row * row_h) - _e5);
    float _e7 = feature_height();
    float y_bot = (y_top + _e7);
    float _e9 = canvas_height();
    float px2clip = (2.0 / _e9);
    float _e12 = coverage_offset();
    float _e13 = canvas_height();
    float top_clip = (1.0 - ((_e12 / _e13) * 2.0));
    return vec2((top_clip - (y_top * px2clip)), (top_clip - (y_bot * px2clip)));
}

vec2 cigar_domain() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float cigar_domain_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float sx1_ = 0.0;
    float sx2_ = 0.0;
    ModInst inst = _fetch_ModInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = cigar_domain_len();
    vec2 _e47 = cigar_domain();
    float pos = float(inst.position);
    sx1_ = ((((pos - _e47.x) / _e46) * 2.0) - 1.0);
    sx2_ = (((((pos + 1.0) - _e47.x) / _e46) * 2.0) - 1.0);
    float _e68 = canvas_width();
    float min_w = (2.0 / _e68);
    float _e71 = sx2_;
    float _e72 = sx1_;
    if (((_e71 - _e72) < min_w)) {
        float _e75 = sx1_;
        float _e76 = sx2_;
        float mid = ((_e75 + _e76) * 0.5);
        sx1_ = (mid - (min_w * 0.5));
        sx2_ = (mid + (min_w * 0.5));
    }
    vec2 _e88 = pileup_y(float(inst.y));
    float _e90 = sx1_;
    float _e91 = sx2_;
    out_.position = vec4(mix(_e90, _e91, lx), mix(_e88.y, _e88.x, ly), 0.0, 1.0);
    uint pc = inst.packed_color;
    out_.color = vec4((float((pc & 255u)) / 255.0), (float(((pc >> 8u) & 255u)) / 255.0), (float(((pc >> 16u) & 255u)) / 255.0), (float(((pc >> 24u) & 255u)) / 255.0));
    VertexOutput _e128 = out_;
    gl_Position = _e128.position;
    _vs2fs_location0 = _e128.color;
    return;
}

`

export const MODIFICATION_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const COVERAGE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct CovInst {
    float position;
    float depth;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

CovInst _fetch_CovInst(int idx) {
    int base = idx * 2;
    CovInst s;
    s.position = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.depth = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

vec2 vis_range() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float vis_range_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

float cov_height() {
    float _e1 = uf(16u);
    return _e1;
}

float cov_y_offset() {
    float _e1 = uf(17u);
    return _e1;
}

float depth_scale() {
    float _e1 = uf(18u);
    return _e1;
}

float eff_height() {
    float _e0 = cov_height();
    float _e1 = cov_y_offset();
    return (_e0 - (2.0 * _e1));
}

float cov_bottom() {
    float _e0 = cov_height();
    float _e1 = cov_y_offset();
    float _e3 = canvas_height();
    return (1.0 - (((_e0 - _e1) / _e3) * 2.0));
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float x1_ = 0.0;
    float x2_ = 0.0;
    CovInst inst = _fetch_CovInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = vis_range_len();
    vec2 _e47 = vis_range();
    x1_ = ((((inst.position - _e47.x) / _e46) * 2.0) - 1.0);
    float _e59 = uf(19u);
    x2_ = (((((inst.position + _e59) - _e47.x) / _e46) * 2.0) - 1.0);
    float _e69 = canvas_width();
    float min_w = (2.0 / _e69);
    float _e72 = x2_;
    float _e73 = x1_;
    if (((_e72 - _e73) < min_w)) {
        float _e76 = x1_;
        float _e77 = x2_;
        float m = ((_e76 + _e77) * 0.5);
        x1_ = (m - (min_w * 0.5));
        x2_ = (m + (min_w * 0.5));
    }
    float _e87 = cov_bottom();
    float _e89 = depth_scale();
    float _e91 = eff_height();
    float _e93 = canvas_height();
    float bar_top = (_e87 + ((((inst.depth * _e89) * _e91) / _e93) * 2.0));
    float _e99 = x1_;
    float _e100 = x2_;
    float _e102 = cov_bottom();
    out_.position = vec4(mix(_e99, _e100, lx), mix(_e102, bar_top, ly), 0.0, 1.0);
    vec3 _e109 = color3_(80u);
    out_.color = vec4(_e109, 1.0);
    VertexOutput _e112 = out_;
    gl_Position = _e112.position;
    _vs2fs_location0 = _e112.color;
    return;
}

`

export const COVERAGE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const SNP_COVERAGE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct SnpCovInst {
    float position;
    float y_offset;
    float seg_height;
    float color_type;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

SnpCovInst _fetch_SnpCovInst(int idx) {
    int base = idx * 4;
    SnpCovInst s;
    s.position = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.y_offset = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.seg_height = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

vec2 vis_range() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float vis_range_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

float cov_height() {
    float _e1 = uf(16u);
    return _e1;
}

float cov_y_offset() {
    float _e1 = uf(17u);
    return _e1;
}

float depth_scale() {
    float _e1 = uf(18u);
    return _e1;
}

float eff_height() {
    float _e0 = cov_height();
    float _e1 = cov_y_offset();
    return (_e0 - (2.0 * _e1));
}

float cov_bottom() {
    float _e0 = cov_height();
    float _e1 = cov_y_offset();
    float _e3 = canvas_height();
    return (1.0 - (((_e0 - _e1) / _e3) * 2.0));
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float x1_ = 0.0;
    float x2_ = 0.0;
    vec3 c = vec3(0.0);
    SnpCovInst inst = _fetch_SnpCovInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = vis_range_len();
    vec2 _e47 = vis_range();
    x1_ = ((((inst.position - _e47.x) / _e46) * 2.0) - 1.0);
    x2_ = (((((inst.position + 1.0) - _e47.x) / _e46) * 2.0) - 1.0);
    float _e68 = canvas_width();
    float min_w = (2.0 / _e68);
    float _e71 = x2_;
    float _e72 = x1_;
    if (((_e71 - _e72) < min_w)) {
        float _e75 = x1_;
        float _e76 = x2_;
        float m = ((_e75 + _e76) * 0.5);
        x1_ = (m - (min_w * 0.5));
        x2_ = (m + (min_w * 0.5));
    }
    float _e86 = cov_bottom();
    float _e88 = depth_scale();
    float _e90 = eff_height();
    float _e92 = canvas_height();
    float s_bot = (_e86 + ((((inst.y_offset * _e88) * _e90) / _e92) * 2.0));
    float _e98 = depth_scale();
    float _e100 = eff_height();
    float _e102 = canvas_height();
    float s_top = (s_bot + ((((inst.seg_height * _e98) * _e100) / _e102) * 2.0));
    float _e108 = x1_;
    float _e109 = x2_;
    out_.position = vec4(mix(_e108, _e109, lx), mix(s_bot, s_top, ly), 0.0, 1.0);
    int ci = int(inst.color_type);
    if ((ci == 1)) {
        vec3 _e121 = color3_(53u);
        c = _e121;
    } else {
        if ((ci == 2)) {
            vec3 _e125 = color3_(56u);
            c = _e125;
        } else {
            if ((ci == 3)) {
                vec3 _e129 = color3_(59u);
                c = _e129;
            } else {
                vec3 _e131 = color3_(62u);
                c = _e131;
            }
        }
    }
    vec3 _e133 = c;
    out_.color = vec4(_e133, 1.0);
    VertexOutput _e136 = out_;
    gl_Position = _e136.position;
    _vs2fs_location0 = _e136.color;
    return;
}

`

export const SNP_COVERAGE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const MOD_COVERAGE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct ModCovInst {
    float position;
    float y_offset;
    float seg_height;
    uint packed_color;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_4_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ModCovInst _fetch_ModCovInst(int idx) {
    int base = idx * 4;
    ModCovInst s;
    s.position = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.y_offset = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.seg_height = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.packed_color = texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4];
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

vec2 vis_range() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float vis_range_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

float cov_height() {
    float _e1 = uf(16u);
    return _e1;
}

float cov_y_offset() {
    float _e1 = uf(17u);
    return _e1;
}

float depth_scale() {
    float _e1 = uf(18u);
    return _e1;
}

float eff_height() {
    float _e0 = cov_height();
    float _e1 = cov_y_offset();
    return (_e0 - (2.0 * _e1));
}

float cov_bottom() {
    float _e0 = cov_height();
    float _e1 = cov_y_offset();
    float _e3 = canvas_height();
    return (1.0 - (((_e0 - _e1) / _e3) * 2.0));
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    float x1_ = 0.0;
    float x2_ = 0.0;
    ModCovInst inst = _fetch_ModCovInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = vis_range_len();
    vec2 _e47 = vis_range();
    x1_ = ((((inst.position - _e47.x) / _e46) * 2.0) - 1.0);
    x2_ = (((((inst.position + 1.0) - _e47.x) / _e46) * 2.0) - 1.0);
    float _e68 = canvas_width();
    float min_w = (2.0 / _e68);
    float _e71 = x2_;
    float _e72 = x1_;
    if (((_e71 - _e72) < min_w)) {
        float _e75 = x1_;
        float _e76 = x2_;
        float m = ((_e75 + _e76) * 0.5);
        x1_ = (m - (min_w * 0.5));
        x2_ = (m + (min_w * 0.5));
    }
    float _e86 = cov_bottom();
    float _e88 = depth_scale();
    float _e90 = eff_height();
    float _e92 = canvas_height();
    float s_bot = (_e86 + ((((inst.y_offset * _e88) * _e90) / _e92) * 2.0));
    float _e98 = depth_scale();
    float _e100 = eff_height();
    float _e102 = canvas_height();
    float s_top = (s_bot + ((((inst.seg_height * _e98) * _e100) / _e102) * 2.0));
    float _e108 = x1_;
    float _e109 = x2_;
    out_.position = vec4(mix(_e108, _e109, lx), mix(s_bot, s_top, ly), 0.0, 1.0);
    uint pc = inst.packed_color;
    out_.color = vec4((float((pc & 255u)) / 255.0), (float(((pc >> 8u) & 255u)) / 255.0), (float(((pc >> 16u) & 255u)) / 255.0), (float(((pc >> 24u) & 255u)) / 255.0));
    VertexOutput _e144 = out_;
    gl_Position = _e144.position;
    _vs2fs_location0 = _e144.color;
    return;
}

`

export const MOD_COVERAGE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const NONCOV_HISTOGRAM_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct NoncovInst {
    float position;
    float y_offset;
    float seg_height;
    float color_type;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

NoncovInst _fetch_NoncovInst(int idx) {
    int base = idx * 4;
    NoncovInst s;
    s.position = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.y_offset = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.seg_height = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

vec2 vis_range() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float vis_range_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    vec3 c = vec3(0.0);
    NoncovInst inst = _fetch_NoncovInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    float _e46 = vis_range_len();
    vec2 _e47 = vis_range();
    float cx = ((((inst.position - _e47.x) / _e46) * 2.0) - 1.0);
    float _e56 = canvas_width();
    float bar_w = ((1.0 / _e56) * 2.0);
    float _e62 = uf(20u);
    float _e63 = canvas_height();
    float ind_off = ((4.5 / _e63) * 2.0);
    float _e72 = canvas_height();
    float s_top = ((1.0 - ind_off) - (((inst.y_offset * _e62) / _e72) * 2.0));
    float _e79 = canvas_height();
    float s_bot = (s_top - (((inst.seg_height * _e62) / _e79) * 2.0));
    out_.position = vec4(mix((cx - (bar_w * 0.5)), (cx + (bar_w * 0.5)), lx), mix(s_bot, s_top, ly), 0.0, 1.0);
    int ci = int(inst.color_type);
    if ((ci == 1)) {
        vec3 _e102 = color3_(65u);
        c = _e102;
    } else {
        if ((ci == 2)) {
            vec3 _e106 = color3_(74u);
            c = _e106;
        } else {
            vec3 _e108 = color3_(77u);
            c = _e108;
        }
    }
    vec3 _e110 = c;
    out_.color = vec4(_e110, 1.0);
    VertexOutput _e113 = out_;
    gl_Position = _e113.position;
    _vs2fs_location0 = _e113.color;
    return;
}

`

export const NONCOV_HISTOGRAM_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const INDICATOR_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct IndicatorInst {
    float position;
    float color_type;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

IndicatorInst _fetch_IndicatorInst(int idx) {
    int base = idx * 2;
    IndicatorInst s;
    s.position = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

vec2 vis_range() {
    float _e1 = uf(30u);
    float _e3 = uf(31u);
    return vec2(_e1, _e3);
}

float vis_range_len() {
    float _e1 = uf(31u);
    float _e3 = uf(30u);
    return (_e1 - _e3);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    float sx = 0.0;
    float sy = 0.0;
    vec3 c = vec3(0.0);
    IndicatorInst inst = _fetch_IndicatorInst(int(iid));
    uint v = (vid % 3u);
    float _e8 = vis_range_len();
    vec2 _e9 = vis_range();
    float cx = ((((inst.position - _e9.x) / _e8) * 2.0) - 1.0);
    float _e18 = canvas_width();
    float tw = ((7.0 / _e18) * 2.0);
    float _e23 = canvas_height();
    float th = ((4.5 / _e23) * 2.0);
    if ((v == 0u)) {
        sx = (cx - (tw * 0.5));
        sy = 1.0;
    } else {
        if ((v == 1u)) {
            sx = (cx + (tw * 0.5));
            sy = 1.0;
        } else {
            sx = cx;
            sy = (1.0 - th);
        }
    }
    float _e45 = sx;
    float _e46 = sy;
    out_.position = vec4(_e45, _e46, 0.0, 1.0);
    int ci = int(inst.color_type);
    if ((ci == 1)) {
        vec3 _e56 = color3_(65u);
        c = _e56;
    } else {
        if ((ci == 2)) {
            vec3 _e60 = color3_(74u);
            c = _e60;
        } else {
            vec3 _e62 = color3_(77u);
            c = _e62;
        }
    }
    vec3 _e64 = c;
    out_.color = vec4(_e64, 1.0);
    VertexOutput _e67 = out_;
    gl_Position = _e67.position;
    _vs2fs_location0 = _e67.color;
    return;
}

`

export const INDICATOR_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const SEPARATOR_LINE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct LineVert {
    float x;
    float y;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_3_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

LineVert _fetch_LineVert(int idx) {
    int base = idx * 2;
    LineVert s;
    s.x = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

void main() {
    uint vid = uint(gl_VertexID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    LineVert v = _fetch_LineVert(int(vid));
    out_.position = vec4(v.x, v.y, 0.0, 1.0);
    float _e13 = uf(0u);
    float _e15 = uf(1u);
    float _e17 = uf(2u);
    float _e19 = uf(3u);
    out_.color = vec4(_e13, _e15, _e17, _e19);
    VertexOutput _e21 = out_;
    gl_Position = _e21.position;
    _vs2fs_location0 = _e21.color;
    return;
}

`

export const SEPARATOR_LINE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const ARC_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct ArcInst {
    float x1_;
    float x2_;
    float color_type;
    float is_arc;
};
struct ArcOut {
    vec4 position;
    vec4 color;
    float dist;
};
const uint HP_LOW_MASK = 4095u;
const uint SEGMENTS = 64u;
const float PI = 3.1415927;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ArcInst _fetch_ArcInst(int idx) {
    int base = idx * 4;
    ArcInst s;
    s.x1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.x2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.is_arc = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;
smooth out float _vs2fs_location1;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

vec3 arc_color(float ct) {
    vec3 rgb = vec3(0.0);
    uint idx = uint((ct + 0.5));
    if ((idx < 8u)) {
        vec3 _e10 = color3_((98u + (idx * 3u)));
        return _e10;
    }
    float _e12 = uf(27u);
    float h = (_e12 / 360.0);
    float xc = (0.5 * (1.0 - abs((((h * 6.0) - 2.0 * trunc((h * 6.0) / 2.0)) - 1.0))));
    if ((h < 0.16666667)) {
        rgb = vec3(0.5, xc, 0.0);
    } else {
        if ((h < 0.33333334)) {
            rgb = vec3(xc, 0.5, 0.0);
        } else {
            if ((h < 0.5)) {
                rgb = vec3(0.0, 0.5, xc);
            } else {
                if ((h < 0.6666667)) {
                    rgb = vec3(0.0, xc, 0.5);
                } else {
                    if ((h < 0.8333333)) {
                        rgb = vec3(xc, 0.0, 0.5);
                    } else {
                        rgb = vec3(0.5, 0.0, xc);
                    }
                }
            }
        }
    }
    vec3 _e50 = rgb;
    return (_e50 + vec3(0.25));
}

vec2 eval_arc(float t, ArcInst inst) {
    float x_bp = 0.0;
    float y_px = 0.0;
    float radius = ((inst.x2_ - inst.x1_) / 2.0);
    float absrad = abs(radius);
    float cx = (inst.x1_ + radius);
    float _e11 = uf(25u);
    float _e13 = uf(2u);
    float px_per_bp = (_e11 / _e13);
    float absrad_px = (absrad * px_per_bp);
    float _e16 = canvas_height();
    float _e17 = coverage_offset();
    float avail_h = (_e16 - _e17);
    float dest_y = min(avail_h, absrad_px);
    if ((inst.is_arc > 0.5)) {
        float angle = (t * PI);
        x_bp = (cx + (cos(angle) * radius));
        y_px = ((absrad_px > 0.0) ? ((sin(angle) * absrad_px) * (dest_y / absrad_px)) : 0.0);
    } else {
        float mt = (1.0 - t);
        float mt2_ = (mt * mt);
        float mt3_ = (mt2_ * mt);
        float t2_ = (t * t);
        float t3_ = (t2_ * t);
        x_bp = ((((mt3_ * inst.x1_) + (((3.0 * mt2_) * t) * inst.x1_)) + (((3.0 * mt) * t2_) * inst.x2_)) + (t3_ * inst.x2_));
        y_px = ((((3.0 * mt2_) * t) * dest_y) + (((3.0 * mt) * t2_) * dest_y));
    }
    float _e71 = uf(24u);
    float _e72 = x_bp;
    float _e74 = uf(30u);
    float screen_x = (_e71 + ((_e72 - _e74) * px_per_bp));
    float _e78 = y_px;
    return vec2(screen_x, _e78);
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    ArcOut out_ = ArcOut(vec4(0.0), vec4(0.0), 0.0);
    vec2 normal = vec2(0.0);
    ArcInst inst_1 = _fetch_ArcInst(int(iid));
    uint seg = (vid / 2u);
    uint side_idx = (vid % 2u);
    float side = ((side_idx == 0u) ? 1.0 : -1.0);
    float t_1 = (float(seg) / 64.0);
    vec2 _e18 = eval_arc(t_1, inst_1);
    vec2 _e25 = eval_arc(max((t_1 - (0.015625 * 0.5)), 0.0), inst_1);
    vec2 _e31 = eval_arc(min((t_1 + (0.015625 * 0.5)), 1.0), inst_1);
    vec2 tang = (_e31 - _e25);
    float tlen = length(tang);
    if ((tlen > 0.001)) {
        vec2 tn = (tang / vec2(tlen));
        normal = vec2(-(tn.y), tn.x);
    } else {
        normal = vec2(0.0, 1.0);
    }
    float _e47 = uf(26u);
    float hw = ((_e47 * 0.5) + 0.5);
    vec2 _e52 = normal;
    vec2 offset_pos = (_e18 + ((_e52 * hw) * side));
    float _e57 = canvas_width();
    float clip_x = (((offset_pos.x / _e57) * 2.0) - 1.0);
    float _e64 = coverage_offset();
    float _e66 = canvas_height();
    float clip_y = (1.0 - (((offset_pos.y + _e64) / _e66) * 2.0));
    out_.position = vec4(clip_x, clip_y, 0.0, 1.0);
    out_.dist = (side * hw);
    vec3 _e80 = arc_color(inst_1.color_type);
    out_.color = vec4(_e80, 1.0);
    ArcOut _e83 = out_;
    gl_Position = _e83.position;
    _vs2fs_location0 = _e83.color;
    _vs2fs_location1 = _e83.dist;
    return;
}

`

export const ARC_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct ArcOut {
    vec4 position;
    vec4 color;
    float dist;
};
const uint HP_LOW_MASK = 4095u;
const uint SEGMENTS = 64u;
const float PI = 3.1415927;

layout(std140) uniform type_3_block_0Fragment { uvec4 _group_0_binding_1_fs[40]; };

smooth in vec4 _vs2fs_location0;
smooth in float _vs2fs_location1;
out vec4 _fs2p_location0;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_fs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

void main() {
    ArcOut in_ = ArcOut(gl_FragCoord, _vs2fs_location0, _vs2fs_location1);
    float _e2 = uf(26u);
    float hw = (_e2 * 0.5);
    float d = abs(in_.dist);
    float aa = fwidth(in_.dist);
    float alpha = (1.0 - smoothstep((hw - (aa * 0.5)), (hw + aa), d));
    _fs2p_location0 = vec4(in_.color.xyz, (in_.color.w * alpha));
    return;
}

`

export const ARC_LINE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct ArcLineInst {
    uint position;
    float y;
    float color_type;
    float _pad;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ArcLineInst _fetch_ArcLineInst(int idx) {
    int base = idx * 4;
    ArcLineInst s;
    s.position = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s._pad = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_scale_linear(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((hi_1 + lo_1) / bp_range.z);
}

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

uint uu(uint i_1) {
    uint _e8 = _group_0_binding_1_vs[(i_1 / 4u)][(i_1 % 4u)];
    return _e8;
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

vec3 bp_range_1() {
    float _e1 = uf(0u);
    float _e3 = uf(1u);
    float _e5 = uf(2u);
    return vec3(_e1, _e3, _e5);
}

uint region_start() {
    uint _e1 = uu(3u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    float sy = 0.0;
    ArcLineInst inst = _fetch_ArcLineInst(int(iid));
    uint v = (vid % 2u);
    uint _e9 = region_start();
    uint abs_pos = (inst.position + _e9);
    vec2 _e11 = hp_split_uint(abs_pos);
    vec3 _e12 = bp_range_1();
    float _e13 = hp_scale_linear(_e11, _e12);
    float _e15 = uf(24u);
    float _e17 = uf(25u);
    float screen_x = (_e15 + (_e13 * _e17));
    float _e20 = canvas_width();
    float sx = (((screen_x / _e20) * 2.0) - 1.0);
    if ((v == 0u)) {
        float _e30 = coverage_offset();
        float _e32 = canvas_height();
        sy = (1.0 - (((inst.y + _e30) / _e32) * 2.0));
    } else {
        float _e38 = coverage_offset();
        float _e39 = canvas_height();
        sy = (1.0 - ((_e38 / _e39) * 2.0));
    }
    float _e46 = sy;
    out_.position = vec4(sx, _e46, 0.0, 1.0);
    uint idx = uint((inst.color_type + 0.5));
    uint ci = min(idx, 1u);
    vec3 _e61 = color3_((122u + (ci * 3u)));
    out_.color = vec4(_e61, 1.0);
    VertexOutput _e64 = out_;
    gl_Position = _e64.position;
    _vs2fs_location0 = _e64.color;
    return;
}

`

export const ARC_LINE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const SASHIMI_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct SashimiInst {
    float x1_;
    float x2_;
    float color_type;
    float line_width;
};
struct SashimiOut {
    vec4 position;
    vec4 color;
    float dist;
    float lw;
};
const uint HP_LOW_MASK = 4095u;
const uint SEGMENTS = 64u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

SashimiInst _fetch_SashimiInst(int idx) {
    int base = idx * 4;
    SashimiInst s;
    s.x1_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4]);
    s.x2_ = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.line_width = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;
smooth out float _vs2fs_location1;
smooth out float _vs2fs_location2;

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

vec3 color3_(uint base) {
    float _e1 = uf(base);
    float _e4 = uf((base + 1u));
    float _e7 = uf((base + 2u));
    return vec3(_e1, _e4, _e7);
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float canvas_width() {
    float _e1 = uf(7u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

vec2 eval_sashimi(float t, SashimiInst inst) {
    float mt = (1.0 - t);
    float mt2_ = (mt * mt);
    float mt3_ = (mt2_ * mt);
    float t2_ = (t * t);
    float t3_ = (t2_ * t);
    float x_bp = ((((mt3_ * inst.x1_) + (((3.0 * mt2_) * t) * inst.x1_)) + (((3.0 * mt) * t2_) * inst.x2_)) + (t3_ * inst.x2_));
    float _e26 = uf(16u);
    float dest_y = (_e26 * 1.0666667);
    float y_px = ((((3.0 * mt2_) * t) * dest_y) + (((3.0 * mt) * t2_) * dest_y));
    float _e39 = uf(25u);
    float _e41 = uf(2u);
    float px_per_bp = (_e39 / _e41);
    float _e44 = uf(24u);
    float _e46 = uf(30u);
    float screen_x = (_e44 + ((x_bp - _e46) * px_per_bp));
    return vec2(screen_x, ((0.9 * _e26) - y_px));
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    SashimiOut out_ = SashimiOut(vec4(0.0), vec4(0.0), 0.0, 0.0);
    vec2 normal = vec2(0.0);
    SashimiInst inst_1 = _fetch_SashimiInst(int(iid));
    uint seg = (vid / 2u);
    float side = (((vid % 2u) == 0u) ? 1.0 : -1.0);
    float t_1 = (float(seg) / 64.0);
    vec2 _e18 = eval_sashimi(t_1, inst_1);
    vec2 _e25 = eval_sashimi(max((t_1 - (0.015625 * 0.5)), 0.0), inst_1);
    vec2 _e31 = eval_sashimi(min((t_1 + (0.015625 * 0.5)), 1.0), inst_1);
    vec2 tang = (_e31 - _e25);
    float tlen = length(tang);
    if ((tlen > 0.001)) {
        vec2 tn = (tang / vec2(tlen));
        normal = vec2(-(tn.y), tn.x);
    } else {
        normal = vec2(0.0, 1.0);
    }
    float hw = ((inst_1.line_width * 0.5) + 0.5);
    vec2 _e51 = normal;
    vec2 offset_pos = (_e18 + ((_e51 * hw) * side));
    float _e56 = canvas_width();
    float clip_x = (((offset_pos.x / _e56) * 2.0) - 1.0);
    float _e63 = coverage_offset();
    float _e65 = canvas_height();
    float clip_y = (1.0 - (((offset_pos.y + _e63) / _e65) * 2.0));
    out_.position = vec4(clip_x, clip_y, 0.0, 1.0);
    out_.dist = (side * hw);
    out_.lw = inst_1.line_width;
    uint idx = min(uint((inst_1.color_type + 0.5)), 1u);
    vec3 _e90 = color3_((128u + (idx * 3u)));
    out_.color = vec4(_e90, 1.0);
    SashimiOut _e93 = out_;
    gl_Position = _e93.position;
    _vs2fs_location0 = _e93.color;
    _vs2fs_location1 = _e93.dist;
    _vs2fs_location2 = _e93.lw;
    return;
}

`

export const SASHIMI_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct SashimiOut {
    vec4 position;
    vec4 color;
    float dist;
    float lw;
};
const uint HP_LOW_MASK = 4095u;
const uint SEGMENTS = 64u;

smooth in vec4 _vs2fs_location0;
smooth in float _vs2fs_location1;
smooth in float _vs2fs_location2;
out vec4 _fs2p_location0;

void main() {
    SashimiOut in_ = SashimiOut(gl_FragCoord, _vs2fs_location0, _vs2fs_location1, _vs2fs_location2);
    float hw = (in_.lw * 0.5);
    float d = abs(in_.dist);
    float aa = fwidth(in_.dist);
    float alpha = (1.0 - smoothstep((hw - (aa * 0.5)), (hw + aa), d));
    _fs2p_location0 = vec4(in_.color.xyz, (in_.color.w * alpha));
    return;
}

`

export const CLOUD_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct CloudInst {
    uint start_off;
    uint end_off;
    float y;
    float flags;
    float color_type;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

CloudInst _fetch_CloudInst(int idx) {
    int base = idx * 5;
    CloudInst s;
    s.start_off = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.end_off = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.flags = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.color_type = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

uint uu(uint i_1) {
    uint _e8 = _group_0_binding_1_vs[(i_1 / 4u)][(i_1 % 4u)];
    return _e8;
}

int ui(uint i_2) {
    uint _e8 = _group_0_binding_1_vs[(i_2 / 4u)][(i_2 % 4u)];
    return int(_e8);
}

vec3 bp_range_1() {
    float _e1 = uf(0u);
    float _e3 = uf(1u);
    float _e5 = uf(2u);
    return vec3(_e1, _e3, _e5);
}

uint region_start() {
    uint _e1 = uu(3u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

vec3 iso_color(float ct, float flags) {
    if ((ct < 0.5)) {
        return vec3(0.55);
    }
    if ((ct < 1.5)) {
        return vec3(0.85, 0.25, 0.25);
    }
    if ((ct < 2.5)) {
        return vec3(0.25, 0.35, 0.85);
    }
    if ((ct < 3.5)) {
        return vec3(0.5, 0.0, 0.5);
    }
    return vec3(0.0, 0.5, 0.0);
}

vec3 cloud_strand(float flags_1) {
    bool is_rev = (fract((floor((flags_1 / 16.0)) / 2.0)) > 0.25);
    return (is_rev ? vec3(0.55, 0.55, 0.85) : vec3(0.85, 0.55, 0.55));
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    vec3 c = vec3(0.0);
    CloudInst inst = _fetch_CloudInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    uint _e47 = region_start();
    uint abs_start = (inst.start_off + _e47);
    uint _e50 = region_start();
    uint abs_end = (inst.end_off + _e50);
    vec2 _e52 = hp_split_uint(abs_start);
    vec3 _e53 = bp_range_1();
    float _e54 = hp_to_clip_x(_e52, _e53);
    vec2 _e55 = hp_split_uint(abs_end);
    vec3 _e56 = bp_range_1();
    float _e57 = hp_to_clip_x(_e55, _e56);
    float _e58 = canvas_height();
    float _e59 = coverage_offset();
    float avail = (_e58 - _e59);
    float _e61 = coverage_offset();
    float _e67 = feature_height();
    float y_top_px = ((_e61 + ((1.0 - inst.y) * avail)) - (_e67 * 0.5));
    float _e71 = feature_height();
    float y_bot_px = (y_top_px + _e71);
    float _e73 = canvas_height();
    float px2clip = (2.0 / _e73);
    float sy_top = (1.0 - (y_top_px * px2clip));
    float sy_bot = (1.0 - (y_bot_px * px2clip));
    out_.position = vec4(mix(_e54, _e57, lx), mix(sy_bot, sy_top, ly), 0.0, 1.0);
    int _e89 = ui(29u);
    if ((_e89 == 0)) {
        vec3 _e95 = iso_color(inst.color_type, inst.flags);
        c = _e95;
    } else {
        if ((_e89 == 1)) {
            vec3 _e99 = cloud_strand(inst.flags);
            c = _e99;
        } else {
            c = vec3(0.55);
        }
    }
    vec3 _e103 = c;
    out_.color = vec4(_e103, 1.0);
    VertexOutput _e106 = out_;
    gl_Position = _e106.position;
    _vs2fs_location0 = _e106.color;
    return;
}

`

export const CLOUD_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

export const CONNECTING_LINE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct VertexOutput {
    vec4 position;
    vec4 color;
};
struct ConnLineInst {
    uint start_off;
    uint end_off;
    float y;
};
const uint HP_LOW_MASK = 4095u;

layout(std140) uniform type_5_block_0Vertex { uvec4 _group_0_binding_1_vs[40]; };

uniform highp usampler2D u_instanceData;

ConnLineInst _fetch_ConnLineInst(int idx) {
    int base = idx * 3;
    ConnLineInst s;
    s.start_off = texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4];
    s.end_off = texelFetch(u_instanceData, ivec2((base + 1) / 4, 0), 0)[(base + 1) % 4];
    s.y = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    return s;
}

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

float uf(uint i) {
    uint _e8 = _group_0_binding_1_vs[(i / 4u)][(i % 4u)];
    return uintBitsToFloat(_e8);
}

uint uu(uint i_1) {
    uint _e8 = _group_0_binding_1_vs[(i_1 / 4u)][(i_1 % 4u)];
    return _e8;
}

vec3 bp_range_1() {
    float _e1 = uf(0u);
    float _e3 = uf(1u);
    float _e5 = uf(2u);
    return vec3(_e1, _e3, _e5);
}

uint region_start() {
    uint _e1 = uu(3u);
    return _e1;
}

float canvas_height() {
    float _e1 = uf(6u);
    return _e1;
}

float coverage_offset() {
    float _e1 = uf(8u);
    return _e1;
}

float feature_height() {
    float _e1 = uf(9u);
    return _e1;
}

float feature_spacing() {
    float _e1 = uf(10u);
    return _e1;
}

void main() {
    uint vid = uint(gl_VertexID);
    uint iid = uint(gl_InstanceID);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    ConnLineInst inst = _fetch_ConnLineInst(int(iid));
    uint v = (vid % 6u);
    if (!((v == 0u))) {
        local = (v == 2u);
    } else {
        local = true;
    }
    bool _e16 = local;
    if (!(_e16)) {
        local_1 = (v == 3u);
    } else {
        local_1 = true;
    }
    bool _e23 = local_1;
    float lx = (_e23 ? 0.0 : 1.0);
    if (!((v == 0u))) {
        local_2 = (v == 1u);
    } else {
        local_2 = true;
    }
    bool _e35 = local_2;
    if (!(_e35)) {
        local_3 = (v == 4u);
    } else {
        local_3 = true;
    }
    bool _e42 = local_3;
    float ly = (_e42 ? 0.0 : 1.0);
    uint _e47 = region_start();
    uint abs_start = (inst.start_off + _e47);
    uint _e50 = region_start();
    uint abs_end = (inst.end_off + _e50);
    vec2 _e52 = hp_split_uint(abs_start);
    vec3 _e53 = bp_range_1();
    float _e54 = hp_to_clip_x(_e52, _e53);
    vec2 _e55 = hp_split_uint(abs_end);
    vec3 _e56 = bp_range_1();
    float _e57 = hp_to_clip_x(_e55, _e56);
    float _e58 = feature_height();
    float _e59 = feature_spacing();
    float row_h = (_e58 + _e59);
    float _e61 = coverage_offset();
    float _e65 = feature_height();
    float _e70 = uf(28u);
    float row_center = (((_e61 + (inst.y * row_h)) + (_e65 * 0.5)) - _e70);
    float y_top = floor((row_center - 0.5));
    float y_bot = (y_top + 1.0);
    float _e77 = canvas_height();
    float px2clip = (2.0 / _e77);
    float sy_top = (1.0 - (y_top * px2clip));
    float sy_bot = (1.0 - (y_bot * px2clip));
    out_.position = vec4(mix(_e54, _e57, lx), mix(sy_bot, sy_top, ly), 0.0, 1.0);
    out_.color = vec4(0.0, 0.0, 0.0, 0.45);
    VertexOutput _e98 = out_;
    gl_Position = _e98.position;
    _vs2fs_location0 = _e98.color;
    return;
}

`

export const CONNECTING_LINE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

const uint HP_LOW_MASK = 4095u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    vec4 color = _vs2fs_location0;
    _fs2p_location0 = color;
    return;
}

`

