<!doctype html>
<html>
  <head>
    <title>Persistent WebGL Pileup - Demo</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #f5f5f5;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }
      h1 {
        margin: 0 0 10px;
        font-size: 24px;
      }
      .subtitle {
        color: #666;
        margin-bottom: 20px;
      }
      .controls {
        display: flex;
        gap: 20px;
        margin-bottom: 15px;
        flex-wrap: wrap;
        align-items: center;
      }
      .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      label {
        font-size: 13px;
        color: #333;
      }
      select,
      input[type='number'] {
        padding: 6px 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
      }
      button {
        padding: 8px 16px;
        background: #4a90d9;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
      }
      button:hover {
        background: #357abd;
      }
      .canvas-container {
        border: 1px solid #ccc;
        border-radius: 4px;
        overflow: hidden;
        background: white;
      }
      canvas {
        display: block;
        cursor: grab;
      }
      canvas:active {
        cursor: grabbing;
      }
      .stats {
        display: flex;
        gap: 20px;
        margin-top: 10px;
        font-size: 12px;
        color: #666;
        font-family: monospace;
      }
      .stat {
        background: #eee;
        padding: 4px 8px;
        border-radius: 3px;
      }
      .instructions {
        margin-top: 15px;
        padding: 15px;
        background: #e8f4fd;
        border-radius: 4px;
        font-size: 13px;
      }
      .instructions strong {
        color: #2a5a8a;
      }
      .perf-indicator {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #0f0;
        padding: 8px 12px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="perf-indicator">
      <div>Frame: <span id="frameTime">0</span>ms</div>
      <div>FPS: <span id="fps">60</span></div>
    </div>

    <div class="container">
      <h1>Persistent WebGL Pileup Display</h1>
      <p class="subtitle">
        Data uploaded once to GPU. Zoom/pan only updates uniforms → instant
        response.
      </p>

      <div class="controls">
        <div class="control-group">
          <label>Color by:</label>
          <select id="colorScheme">
            <option value="0">Strand</option>
            <option value="1">Mapping Quality</option>
            <option value="2">Insert Size</option>
            <option value="3">First of Pair</option>
          </select>
        </div>

        <div class="control-group">
          <label>Reads:</label>
          <input
            type="number"
            id="readCount"
            value="20000"
            min="1000"
            max="200000"
            step="5000"
          />
        </div>

        <div class="control-group">
          <label>Feature Height:</label>
          <input type="number" id="featureHeight" value="7" min="3" max="20" />
        </div>

        <div class="control-group">
          <label
            ><input type="checkbox" id="showMismatches" checked /> Show
            Mismatches</label
          >
        </div>

        <button id="regenerate">Regenerate Data</button>
        <button id="benchmark">Run Benchmark</button>
      </div>

      <div class="canvas-container">
        <canvas id="canvas" width="1200" height="600"></canvas>
      </div>

      <div class="stats">
        <span class="stat">Domain: <span id="domain">0-50000</span></span>
        <span class="stat">bp/px: <span id="bpPerPx">0</span></span>
        <span class="stat">Y Range: <span id="yRange">0-600</span></span>
        <span class="stat">Reads: <span id="readsStat">0</span></span>
        <span class="stat">Mismatches: <span id="mismatchStat">0</span></span>
        <span class="stat">Upload: <span id="uploadTime">0</span>ms</span>
      </div>

      <div class="instructions">
        <strong>Interaction:</strong>
        Scroll to zoom (centered on mouse) • Drag to pan • Shift+Scroll for
        vertical pan<br />
        <strong>Key insight:</strong>
        Once data is uploaded, zoom/pan takes &lt;1ms because only GPU uniforms
        are updated. Color scheme changes are also instant.
      </div>
    </div>

    <script type="module">
      // ============================================================================
      // SHADERS (same as WebGLRenderer.ts)
      // ============================================================================

      const READ_VERTEX_SHADER = `#version 300 es
precision highp float;

in vec2 a_position;
in float a_y;
in float a_flags;
in float a_mapq;
in float a_insertSize;

uniform vec2 u_domainX;
uniform vec2 u_rangeY;
uniform int u_colorScheme;
uniform float u_featureHeight;
uniform float u_featureSpacing;

out vec4 v_color;
out vec2 v_localPos;

vec3 strandColor(float flags) {
  bool isReverse = mod(floor(flags / 16.0), 2.0) > 0.5;
  return isReverse ? vec3(0.53, 0.53, 0.85) : vec3(0.85, 0.53, 0.53);
}

vec3 mapqColor(float mapq) {
  float t = clamp(mapq / 60.0, 0.0, 1.0);
  return mix(vec3(0.85, 0.35, 0.35), vec3(0.35, 0.45, 0.85), t);
}

vec3 insertSizeColor(float insertSize) {
  float normal = 400.0;
  float dev = abs(insertSize - normal) / normal;
  if (insertSize < normal) {
    return mix(vec3(0.55), vec3(0.85, 0.25, 0.25), clamp(dev * 2.0, 0.0, 1.0));
  }
  return mix(vec3(0.55), vec3(0.25, 0.35, 0.85), clamp(dev, 0.0, 1.0));
}

vec3 firstOfPairColor(float flags) {
  bool isFirst = mod(floor(flags / 64.0), 2.0) > 0.5;
  return isFirst ? vec3(0.85, 0.53, 0.53) : vec3(0.53, 0.53, 0.85);
}

void main() {
  int vid = gl_VertexID % 6;
  float localX = (vid == 0 || vid == 2 || vid == 3) ? 0.0 : 1.0;
  float localY = (vid == 0 || vid == 1 || vid == 4) ? 0.0 : 1.0;
  v_localPos = vec2(localX, localY);

  float domainWidth = u_domainX.y - u_domainX.x;
  float sx1 = (a_position.x - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx2 = (a_position.y - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx = mix(sx1, sx2, localX);

  float yRange = u_rangeY.y - u_rangeY.x;
  float rowHeight = u_featureHeight + u_featureSpacing;
  float yTop = a_y * rowHeight;
  float yBot = yTop + u_featureHeight;

  float syTop = 1.0 - (yTop - u_rangeY.x) / yRange * 2.0;
  float syBot = 1.0 - (yBot - u_rangeY.x) / yRange * 2.0;
  float sy = mix(syBot, syTop, localY);

  gl_Position = vec4(sx, sy, 0.0, 1.0);

  vec3 color;
  if (u_colorScheme == 0) color = strandColor(a_flags);
  else if (u_colorScheme == 1) color = mapqColor(a_mapq);
  else if (u_colorScheme == 2) color = insertSizeColor(a_insertSize);
  else if (u_colorScheme == 3) color = firstOfPairColor(a_flags);
  else color = vec3(0.6);

  v_color = vec4(color, 1.0);
}
`

      const READ_FRAGMENT_SHADER = `#version 300 es
precision highp float;
in vec4 v_color;
in vec2 v_localPos;
out vec4 fragColor;
void main() {
  float border = 0.06;
  float darken = (v_localPos.y < border || v_localPos.y > 1.0 - border) ? 0.7 : 1.0;
  fragColor = vec4(v_color.rgb * darken, v_color.a);
}
`

      const MISMATCH_VERTEX_SHADER = `#version 300 es
precision highp float;
in float a_position;
in float a_y;
in float a_base;
uniform vec2 u_domainX;
uniform vec2 u_rangeY;
uniform float u_featureHeight;
uniform float u_featureSpacing;
out vec4 v_color;

const vec3 baseColors[5] = vec3[5](
  vec3(0.35, 0.75, 0.35),
  vec3(0.35, 0.35, 0.85),
  vec3(0.85, 0.65, 0.25),
  vec3(0.85, 0.35, 0.35),
  vec3(0.5, 0.5, 0.5)
);

void main() {
  int vid = gl_VertexID % 6;
  float localX = (vid == 0 || vid == 2 || vid == 3) ? 0.0 : 1.0;
  float localY = (vid == 0 || vid == 1 || vid == 4) ? 0.0 : 1.0;

  float domainWidth = u_domainX.y - u_domainX.x;
  float x1 = a_position;
  float x2 = a_position + 1.0;
  float sx1 = (x1 - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx2 = (x2 - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float minW = 4.0 / domainWidth * 2.0;
  if (sx2 - sx1 < minW) {
    float mid = (sx1 + sx2) * 0.5;
    sx1 = mid - minW * 0.5;
    sx2 = mid + minW * 0.5;
  }
  float sx = mix(sx1, sx2, localX);

  float yRange = u_rangeY.y - u_rangeY.x;
  float rowHeight = u_featureHeight + u_featureSpacing;
  float yTop = a_y * rowHeight;
  float yBot = yTop + u_featureHeight;
  float syTop = 1.0 - (yTop - u_rangeY.x) / yRange * 2.0;
  float syBot = 1.0 - (yBot - u_rangeY.x) / yRange * 2.0;
  float sy = mix(syBot, syTop, localY);

  gl_Position = vec4(sx, sy, 0.0, 1.0);
  v_color = vec4(baseColors[int(clamp(a_base, 0.0, 4.0))], 1.0);
}
`

      const SIMPLE_FRAGMENT = `#version 300 es
precision highp float;
in vec4 v_color;
out vec4 fragColor;
void main() { fragColor = v_color; }
`

      // ============================================================================
      // WEBGL SETUP
      // ============================================================================

      const canvas = document.getElementById('canvas')
      const gl = canvas.getContext('webgl2', {
        antialias: true,
        preserveDrawingBuffer: true,
      })

      function createShader(type, source) {
        const shader = gl.createShader(type)
        gl.shaderSource(shader, source)
        gl.compileShader(shader)
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader))
          return null
        }
        return shader
      }

      function createProgram(vs, fs) {
        const program = gl.createProgram()
        gl.attachShader(program, createShader(gl.VERTEX_SHADER, vs))
        gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fs))
        gl.linkProgram(program)
        return program
      }

      const readProgram = createProgram(
        READ_VERTEX_SHADER,
        READ_FRAGMENT_SHADER,
      )
      const mismatchProgram = createProgram(
        MISMATCH_VERTEX_SHADER,
        SIMPLE_FRAGMENT,
      )

      const readUniforms = {
        domainX: gl.getUniformLocation(readProgram, 'u_domainX'),
        rangeY: gl.getUniformLocation(readProgram, 'u_rangeY'),
        colorScheme: gl.getUniformLocation(readProgram, 'u_colorScheme'),
        featureHeight: gl.getUniformLocation(readProgram, 'u_featureHeight'),
        featureSpacing: gl.getUniformLocation(readProgram, 'u_featureSpacing'),
      }

      const mmUniforms = {
        domainX: gl.getUniformLocation(mismatchProgram, 'u_domainX'),
        rangeY: gl.getUniformLocation(mismatchProgram, 'u_rangeY'),
        featureHeight: gl.getUniformLocation(
          mismatchProgram,
          'u_featureHeight',
        ),
        featureSpacing: gl.getUniformLocation(
          mismatchProgram,
          'u_featureSpacing',
        ),
      }

      // ============================================================================
      // DATA & STATE
      // ============================================================================

      let gpuData = { readVAO: null, readCount: 0, mmVAO: null, mmCount: 0 }
      let layoutMap = new Map()
      let maxY = 0

      const state = {
        domainX: [0, 50000],
        rangeY: [0, 600],
        colorScheme: 0,
        featureHeight: 7,
        featureSpacing: 1,
        showMismatches: true,
      }

      // ============================================================================
      // DATA GENERATION
      // ============================================================================

      function generateReads(count) {
        const reads = []
        const regionSize = 50000

        for (let i = 0; i < count; i++) {
          const len = 80 + Math.random() * 120
          const start = Math.random() * (regionSize - len)
          const flags =
            (Math.random() > 0.5 ? 16 : 0) | (Math.random() > 0.5 ? 64 : 128)

          const mismatches = []
          const mmCount = Math.floor(Math.random() * 4)
          for (let m = 0; m < mmCount; m++) {
            mismatches.push({
              start: Math.floor(Math.random() * len),
              base: 'ACGT'[Math.floor(Math.random() * 4)],
            })
          }

          reads.push({
            id: `read_${i}`,
            start,
            end: start + len,
            flags,
            mapq: Math.floor(Math.random() * 61),
            insertSize: 200 + Math.random() * 400,
            mismatches,
          })
        }
        return reads
      }

      function computeLayout(reads) {
        const sorted = [...reads].sort((a, b) => a.start - b.start)
        const levels = []
        layoutMap.clear()

        for (const read of sorted) {
          let y = 0
          for (let i = 0; i < levels.length; i++) {
            if (levels[i] <= read.start) {
              y = i
              break
            }
            y = i + 1
          }
          layoutMap.set(read.id, y)
          levels[y] = read.end + 2
        }
        return levels.length
      }

      function uploadToGPU(reads) {
        // Clean up
        if (gpuData.readVAO) gl.deleteVertexArray(gpuData.readVAO)
        if (gpuData.mmVAO) gl.deleteVertexArray(gpuData.mmVAO)

        maxY = computeLayout(reads)

        // Prepare arrays
        const positions = new Float32Array(reads.length * 2)
        const ys = new Float32Array(reads.length)
        const flags = new Float32Array(reads.length)
        const mapqs = new Float32Array(reads.length)
        const insertSizes = new Float32Array(reads.length)

        const mismatches = []

        for (let i = 0; i < reads.length; i++) {
          const r = reads[i]
          const y = layoutMap.get(r.id)
          positions[i * 2] = r.start
          positions[i * 2 + 1] = r.end
          ys[i] = y
          flags[i] = r.flags
          mapqs[i] = r.mapq
          insertSizes[i] = r.insertSize

          for (const mm of r.mismatches) {
            mismatches.push({
              pos: r.start + mm.start,
              y,
              base: 'ACGTN'.indexOf(mm.base),
            })
          }
        }

        // Read VAO
        gpuData.readVAO = gl.createVertexArray()
        gl.bindVertexArray(gpuData.readVAO)

        function upload(attrib, data, size) {
          const loc = gl.getAttribLocation(readProgram, attrib)
          if (loc < 0) return
          const buf = gl.createBuffer()
          gl.bindBuffer(gl.ARRAY_BUFFER, buf)
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
          gl.enableVertexAttribArray(loc)
          gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0)
          gl.vertexAttribDivisor(loc, 1)
        }

        upload('a_position', positions, 2)
        upload('a_y', ys, 1)
        upload('a_flags', flags, 1)
        upload('a_mapq', mapqs, 1)
        upload('a_insertSize', insertSizes, 1)
        gpuData.readCount = reads.length
        gl.bindVertexArray(null)

        // Mismatch VAO
        if (mismatches.length > 0) {
          gpuData.mmVAO = gl.createVertexArray()
          gl.bindVertexArray(gpuData.mmVAO)

          function uploadMM(attrib, data) {
            const loc = gl.getAttribLocation(mismatchProgram, attrib)
            if (loc < 0) return
            const buf = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, buf)
            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
            gl.enableVertexAttribArray(loc)
            gl.vertexAttribPointer(loc, 1, gl.FLOAT, false, 0, 0)
            gl.vertexAttribDivisor(loc, 1)
          }

          uploadMM('a_position', new Float32Array(mismatches.map(m => m.pos)))
          uploadMM('a_y', new Float32Array(mismatches.map(m => m.y)))
          uploadMM('a_base', new Float32Array(mismatches.map(m => m.base)))
          gpuData.mmCount = mismatches.length
          gl.bindVertexArray(null)
        } else {
          gpuData.mmVAO = null
          gpuData.mmCount = 0
        }

        document.getElementById('mismatchStat').textContent = gpuData.mmCount
      }

      // ============================================================================
      // RENDERING
      // ============================================================================

      function render() {
        const t0 = performance.now()

        gl.viewport(0, 0, canvas.width, canvas.height)
        gl.clearColor(0.96, 0.96, 0.96, 1.0)
        gl.clear(gl.COLOR_BUFFER_BIT)

        if (!gpuData.readVAO) return

        const bpPerPx = (state.domainX[1] - state.domainX[0]) / canvas.width

        // Pass 1: Reads
        gl.useProgram(readProgram)
        gl.uniform2f(readUniforms.domainX, state.domainX[0], state.domainX[1])
        gl.uniform2f(readUniforms.rangeY, state.rangeY[0], state.rangeY[1])
        gl.uniform1i(readUniforms.colorScheme, state.colorScheme)
        gl.uniform1f(readUniforms.featureHeight, state.featureHeight)
        gl.uniform1f(readUniforms.featureSpacing, state.featureSpacing)

        gl.bindVertexArray(gpuData.readVAO)
        gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, gpuData.readCount)

        // Pass 2: Mismatches (if zoomed in)
        if (state.showMismatches && bpPerPx < 10 && gpuData.mmVAO) {
          gl.useProgram(mismatchProgram)
          gl.uniform2f(mmUniforms.domainX, state.domainX[0], state.domainX[1])
          gl.uniform2f(mmUniforms.rangeY, state.rangeY[0], state.rangeY[1])
          gl.uniform1f(mmUniforms.featureHeight, state.featureHeight)
          gl.uniform1f(mmUniforms.featureSpacing, state.featureSpacing)

          gl.bindVertexArray(gpuData.mmVAO)
          gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, gpuData.mmCount)
        }

        gl.bindVertexArray(null)

        const frameTime = performance.now() - t0
        document.getElementById('frameTime').textContent = frameTime.toFixed(2)

        // Update stats
        document.getElementById('domain').textContent =
          `${Math.round(state.domainX[0])}-${Math.round(state.domainX[1])}`
        document.getElementById('bpPerPx').textContent = bpPerPx.toFixed(2)
        document.getElementById('yRange').textContent =
          `${state.rangeY[0].toFixed(0)}-${state.rangeY[1].toFixed(0)}`
      }

      // ============================================================================
      // INTERACTION
      // ============================================================================

      let isDragging = false,
        lastX = 0,
        lastY = 0

      canvas.addEventListener('mousedown', e => {
        isDragging = true
        lastX = e.clientX
        lastY = e.clientY
      })

      window.addEventListener('mouseup', () => (isDragging = false))

      canvas.addEventListener('mousemove', e => {
        if (!isDragging) return

        const dx = e.clientX - lastX
        const dy = e.clientY - lastY
        lastX = e.clientX
        lastY = e.clientY

        const domainWidth = state.domainX[1] - state.domainX[0]
        const bpPerPx = domainWidth / canvas.width
        state.domainX[0] -= dx * bpPerPx
        state.domainX[1] -= dx * bpPerPx

        const yRange = state.rangeY[1] - state.rangeY[0]
        const pxPerY = yRange / canvas.height
        state.rangeY[0] += dy * pxPerY
        state.rangeY[1] += dy * pxPerY

        if (state.rangeY[0] < 0) {
          state.rangeY[1] -= state.rangeY[0]
          state.rangeY[0] = 0
        }

        render()
      })

      canvas.addEventListener('wheel', e => {
        e.preventDefault()

        if (e.shiftKey) {
          // Vertical scroll
          const panY = e.deltaY * 0.5
          state.rangeY[0] += panY
          state.rangeY[1] += panY
          if (state.rangeY[0] < 0) {
            state.rangeY[1] -= state.rangeY[0]
            state.rangeY[0] = 0
          }
        } else {
          // Zoom
          const rect = canvas.getBoundingClientRect()
          const mouseX = e.clientX - rect.left
          const frac = mouseX / canvas.width

          const domainWidth = state.domainX[1] - state.domainX[0]
          const center = state.domainX[0] + domainWidth * frac
          const factor = e.deltaY > 0 ? 1.15 : 1 / 1.15
          const newWidth = Math.max(50, Math.min(500000, domainWidth * factor))

          state.domainX[0] = center - newWidth * frac
          state.domainX[1] = center + newWidth * (1 - frac)
        }

        render()
      })

      // ============================================================================
      // CONTROLS
      // ============================================================================

      document.getElementById('colorScheme').addEventListener('change', e => {
        state.colorScheme = parseInt(e.target.value)
        render()
      })

      document.getElementById('featureHeight').addEventListener('change', e => {
        state.featureHeight = parseInt(e.target.value)
        render()
      })

      document
        .getElementById('showMismatches')
        .addEventListener('change', e => {
          state.showMismatches = e.target.checked
          render()
        })

      document.getElementById('regenerate').addEventListener('click', () => {
        const count = parseInt(document.getElementById('readCount').value)
        const t0 = performance.now()
        const reads = generateReads(count)
        uploadToGPU(reads)
        const uploadTime = performance.now() - t0

        document.getElementById('uploadTime').textContent =
          uploadTime.toFixed(1)
        document.getElementById('readsStat').textContent = count

        state.rangeY = [0, canvas.height]
        state.domainX = [0, 50000]
        render()
      })

      document.getElementById('benchmark').addEventListener('click', () => {
        const iterations = 100
        const times = []

        for (let i = 0; i < iterations; i++) {
          // Random zoom
          const width = 100 + Math.random() * 49900
          const start = Math.random() * (50000 - width)
          state.domainX = [start, start + width]

          const t0 = performance.now()
          render()
          times.push(performance.now() - t0)
        }

        const avg = times.reduce((a, b) => a + b, 0) / times.length
        const max = Math.max(...times)
        alert(
          `Benchmark (${iterations} random zooms):\nAvg: ${avg.toFixed(2)}ms\nMax: ${max.toFixed(2)}ms`,
        )

        state.domainX = [0, 50000]
        render()
      })

      // ============================================================================
      // FPS COUNTER
      // ============================================================================

      let frameCount = 0
      let lastFpsTime = performance.now()

      function updateFps() {
        frameCount++
        const now = performance.now()
        if (now - lastFpsTime >= 1000) {
          document.getElementById('fps').textContent = frameCount
          frameCount = 0
          lastFpsTime = now
        }
        requestAnimationFrame(updateFps)
      }
      updateFps()

      // ============================================================================
      // INIT
      // ============================================================================

      const initialReads = generateReads(20000)
      const t0 = performance.now()
      uploadToGPU(initialReads)
      document.getElementById('uploadTime').textContent = (
        performance.now() - t0
      ).toFixed(1)
      document.getElementById('readsStat').textContent = '20000'
      render()
    </script>
  </body>
</html>
