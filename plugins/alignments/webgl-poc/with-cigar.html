<!DOCTYPE html>
<html>
<head>
  <title>WebGL Pileup Renderer POC - With CIGAR & Mismatches</title>
  <style>
    body { margin: 0; background: #1a1a1a; color: #fff; font-family: monospace; }
    #container { display: flex; flex-direction: column; height: 100vh; }
    #controls { padding: 10px; background: #2a2a2a; display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
    #info { padding: 10px; background: #2a2a2a; font-size: 12px; }
    canvas { flex: 1; }
    label { display: flex; align-items: center; gap: 5px; }
    select, input { background: #3a3a3a; color: #fff; border: 1px solid #555; padding: 4px; }
    button { background: #4a4a4a; color: #fff; border: 1px solid #666; padding: 6px 12px; cursor: pointer; }
    button:hover { background: #5a5a5a; }
    .section { border-left: 2px solid #555; padding-left: 10px; }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls">
      <div class="section">
        <label>Color by:
          <select id="colorScheme">
            <option value="0">Strand</option>
            <option value="1">MAPQ</option>
            <option value="2">Insert Size</option>
          </select>
        </label>
      </div>
      <div class="section">
        <label>Reads: <input type="range" id="readCount" min="1000" max="50000" value="5000" step="1000"></label>
        <span id="readCountLabel">5000</span>
      </div>
      <div class="section">
        <label><input type="checkbox" id="showMismatches" checked> Show Mismatches</label>
        <label><input type="checkbox" id="showInsertions" checked> Show Insertions</label>
      </div>
      <button id="regenerate">Regenerate</button>
      <span style="font-size: 11px; color: #888;">Scroll=zoom | Drag=pan | Shift+Scroll=vertical</span>
    </div>
    <canvas id="canvas"></canvas>
    <div id="info">
      <span id="stats"></span>
    </div>
  </div>

<!-- Read rectangles vertex shader -->
<script id="read-vertex-shader" type="x-shader/x-vertex">#version 300 es
precision highp float;

// Per-instance attributes
in vec2 a_position;      // x1, x2
in float a_y;
in float a_strand;
in float a_mapq;
in float a_insertSize;

// Uniforms
uniform vec2 u_domainX;
uniform vec2 u_rangeY;
uniform int u_colorScheme;

out vec4 v_color;
out vec2 v_localPos;

vec3 strandColor(float strand) {
  return strand < 0.5 ? vec3(0.75, 0.55, 0.55) : vec3(0.55, 0.55, 0.8);
}

vec3 mapqColor(float mapq) {
  float t = clamp(mapq / 60.0, 0.0, 1.0);
  return mix(vec3(0.9, 0.4, 0.4), vec3(0.4, 0.5, 0.9), t);
}

vec3 insertSizeColor(float insertSize) {
  float deviation = abs(insertSize - 400.0) / 400.0;
  if (insertSize < 400.0) {
    return mix(vec3(0.6), vec3(0.9, 0.3, 0.3), clamp(deviation, 0.0, 1.0));
  }
  return mix(vec3(0.6), vec3(0.3, 0.5, 0.9), clamp(deviation, 0.0, 1.0));
}

void main() {
  float x1 = a_position.x;
  float x2 = a_position.y;

  int vid = gl_VertexID % 6;
  float localX = (vid == 0 || vid == 2 || vid == 3) ? 0.0 : 1.0;
  float localY = (vid == 0 || vid == 1 || vid == 4) ? 0.0 : 1.0;
  v_localPos = vec2(localX, localY);

  float domainWidth = u_domainX.y - u_domainX.x;
  float sx1 = (x1 - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx2 = (x2 - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx = mix(sx1, sx2, localX);

  float yRange = u_rangeY.y - u_rangeY.x;
  float syTop = 1.0 - (a_y - u_rangeY.x) / yRange * 2.0;
  float syBot = 1.0 - (a_y + 1.0 - u_rangeY.x) / yRange * 2.0;
  float sy = mix(syBot, syTop, localY);

  gl_Position = vec4(sx, sy, 0.0, 1.0);

  vec3 color;
  if (u_colorScheme == 0) color = strandColor(a_strand);
  else if (u_colorScheme == 1) color = mapqColor(a_mapq);
  else color = insertSizeColor(a_insertSize);

  v_color = vec4(color, 1.0);
}
</script>

<script id="read-fragment-shader" type="x-shader/x-fragment">#version 300 es
precision highp float;

in vec4 v_color;
in vec2 v_localPos;

out vec4 fragColor;

void main() {
  float border = 0.03;
  float alpha = 1.0;
  if (v_localPos.x < border || v_localPos.x > 1.0 - border ||
      v_localPos.y < border || v_localPos.y > 1.0 - border) {
    alpha = 0.6;
  }
  fragColor = vec4(v_color.rgb * alpha, v_color.a);
}
</script>

<!-- CIGAR gaps (deletions) vertex shader -->
<script id="gap-vertex-shader" type="x-shader/x-vertex">#version 300 es
precision highp float;

in vec2 a_position;  // x1, x2 of gap
in float a_y;

uniform vec2 u_domainX;
uniform vec2 u_rangeY;

void main() {
  int vid = gl_VertexID % 6;
  float localX = (vid == 0 || vid == 2 || vid == 3) ? 0.0 : 1.0;
  float localY = (vid == 0 || vid == 1 || vid == 4) ? 0.0 : 1.0;

  float domainWidth = u_domainX.y - u_domainX.x;
  float sx1 = (a_position.x - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx2 = (a_position.y - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx = mix(sx1, sx2, localX);

  float yRange = u_rangeY.y - u_rangeY.x;
  // Gap is a thin line in the middle of the read
  float yMid = a_y + 0.5;
  float gapHeight = 0.15;
  float syTop = 1.0 - (yMid - gapHeight - u_rangeY.x) / yRange * 2.0;
  float syBot = 1.0 - (yMid + gapHeight - u_rangeY.x) / yRange * 2.0;
  float sy = mix(syBot, syTop, localY);

  gl_Position = vec4(sx, sy, 0.0, 1.0);
}
</script>

<script id="gap-fragment-shader" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 fragColor;
void main() {
  fragColor = vec4(0.1, 0.1, 0.1, 1.0);  // Dark line for deletion
}
</script>

<!-- Mismatches vertex shader -->
<script id="mismatch-vertex-shader" type="x-shader/x-vertex">#version 300 es
precision highp float;

in float a_position;  // Genomic position of mismatch
in float a_y;
in float a_base;      // 0=A, 1=C, 2=G, 3=T

uniform vec2 u_domainX;
uniform vec2 u_rangeY;
uniform float u_bpPerPx;

out vec4 v_color;
out vec2 v_localPos;

vec3 baseColors[4] = vec3[4](
  vec3(0.3, 0.8, 0.3),   // A = green
  vec3(0.3, 0.3, 0.9),   // C = blue
  vec3(0.9, 0.7, 0.2),   // G = orange/yellow
  vec3(0.9, 0.3, 0.3)    // T = red
);

void main() {
  int vid = gl_VertexID % 6;
  float localX = (vid == 0 || vid == 2 || vid == 3) ? 0.0 : 1.0;
  float localY = (vid == 0 || vid == 1 || vid == 4) ? 0.0 : 1.0;
  v_localPos = vec2(localX, localY);

  float domainWidth = u_domainX.y - u_domainX.x;

  // Mismatch is 1bp wide, but ensure minimum screen width
  float x1 = a_position;
  float x2 = a_position + 1.0;

  float sx1 = (x1 - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float sx2 = (x2 - u_domainX.x) / domainWidth * 2.0 - 1.0;

  // Ensure minimum width of ~2 pixels
  float minWidth = 4.0 / domainWidth * 2.0;
  if (sx2 - sx1 < minWidth) {
    float mid = (sx1 + sx2) * 0.5;
    sx1 = mid - minWidth * 0.5;
    sx2 = mid + minWidth * 0.5;
  }

  float sx = mix(sx1, sx2, localX);

  float yRange = u_rangeY.y - u_rangeY.x;
  float syTop = 1.0 - (a_y - u_rangeY.x) / yRange * 2.0;
  float syBot = 1.0 - (a_y + 1.0 - u_rangeY.x) / yRange * 2.0;
  float sy = mix(syBot, syTop, localY);

  gl_Position = vec4(sx, sy, 0.0, 1.0);

  int baseIdx = int(a_base);
  v_color = vec4(baseColors[baseIdx], 1.0);
}
</script>

<script id="mismatch-fragment-shader" type="x-shader/x-fragment">#version 300 es
precision highp float;
in vec4 v_color;
in vec2 v_localPos;
out vec4 fragColor;

void main() {
  fragColor = v_color;
}
</script>

<!-- Insertions vertex shader (small triangles) -->
<script id="insertion-vertex-shader" type="x-shader/x-vertex">#version 300 es
precision highp float;

in float a_position;
in float a_y;

uniform vec2 u_domainX;
uniform vec2 u_rangeY;

out vec4 v_color;

void main() {
  // Draw a small triangle marker
  int vid = gl_VertexID % 3;

  float domainWidth = u_domainX.y - u_domainX.x;
  float yRange = u_rangeY.y - u_rangeY.x;

  float cx = (a_position - u_domainX.x) / domainWidth * 2.0 - 1.0;
  float cy = 1.0 - (a_y + 0.5 - u_rangeY.x) / yRange * 2.0;

  // Triangle size in NDC
  float size = 0.015;

  vec2 offsets[3] = vec2[3](
    vec2(0.0, -size * 1.5),  // Top
    vec2(-size, size),       // Bottom left
    vec2(size, size)         // Bottom right
  );

  gl_Position = vec4(cx + offsets[vid].x, cy + offsets[vid].y, 0.0, 1.0);
  v_color = vec4(0.8, 0.2, 0.8, 1.0);  // Purple for insertions
}
</script>

<script id="insertion-fragment-shader" type="x-shader/x-fragment">#version 300 es
precision highp float;
in vec4 v_color;
out vec4 fragColor;
void main() {
  fragColor = v_color;
}
</script>

<script>
// ============ WebGL Setup ============
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl2', { antialias: true });

if (!gl) {
  alert('WebGL2 not supported');
  throw new Error('WebGL2 not supported');
}

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

// Create all shader programs
const programs = {
  read: createProgram(gl,
    document.getElementById('read-vertex-shader').textContent,
    document.getElementById('read-fragment-shader').textContent),
  gap: createProgram(gl,
    document.getElementById('gap-vertex-shader').textContent,
    document.getElementById('gap-fragment-shader').textContent),
  mismatch: createProgram(gl,
    document.getElementById('mismatch-vertex-shader').textContent,
    document.getElementById('mismatch-fragment-shader').textContent),
  insertion: createProgram(gl,
    document.getElementById('insertion-vertex-shader').textContent,
    document.getElementById('insertion-fragment-shader').textContent),
};

// Get uniform locations
const uniforms = {
  read: {
    domainX: gl.getUniformLocation(programs.read, 'u_domainX'),
    rangeY: gl.getUniformLocation(programs.read, 'u_rangeY'),
    colorScheme: gl.getUniformLocation(programs.read, 'u_colorScheme'),
  },
  gap: {
    domainX: gl.getUniformLocation(programs.gap, 'u_domainX'),
    rangeY: gl.getUniformLocation(programs.gap, 'u_rangeY'),
  },
  mismatch: {
    domainX: gl.getUniformLocation(programs.mismatch, 'u_domainX'),
    rangeY: gl.getUniformLocation(programs.mismatch, 'u_rangeY'),
    bpPerPx: gl.getUniformLocation(programs.mismatch, 'u_bpPerPx'),
  },
  insertion: {
    domainX: gl.getUniformLocation(programs.insertion, 'u_domainX'),
    rangeY: gl.getUniformLocation(programs.insertion, 'u_rangeY'),
  },
};

// ============ Data Structures ============
let reads = [];
let gaps = [];       // Deletions from CIGAR
let mismatches = []; // SNPs
let insertions = []; // Insertion positions

let gpuData = {
  reads: null,
  gaps: null,
  mismatches: null,
  insertions: null,
};

// ============ Data Generation ============
const genomicStart = 0;
const genomicEnd = 50000;
let readCount = 5000;

function computePileupLayout(reads) {
  const sorted = [...reads].sort((a, b) => a.start - b.start);
  const levels = [];
  for (const read of sorted) {
    let y = 0;
    for (let i = 0; i < levels.length; i++) {
      if (levels[i] <= read.start) { y = i; break; }
      y = i + 1;
    }
    read.y = y;
    levels[y] = read.end + 2;
  }
  return Math.max(...levels.map((_, i) => i), 0) + 1;
}

function generateData(count) {
  reads = [];
  gaps = [];
  mismatches = [];
  insertions = [];

  const regionSize = genomicEnd - genomicStart;

  for (let i = 0; i < count; i++) {
    const readLength = 100 + Math.random() * 100;
    const start = genomicStart + Math.random() * (regionSize - readLength);

    // Generate CIGAR-like structure
    // Most reads are simple matches, some have deletions
    const hasDeletion = Math.random() < 0.15;
    let delStart = 0, delEnd = 0;

    if (hasDeletion) {
      const delPos = start + readLength * (0.3 + Math.random() * 0.4);
      const delLen = 5 + Math.random() * 50;
      delStart = delPos;
      delEnd = delPos + delLen;
    }

    const end = start + readLength + (hasDeletion ? (delEnd - delStart) : 0);

    const read = {
      start,
      end,
      strand: Math.random() > 0.5 ? 1 : 0,
      mapq: Math.floor(Math.random() * 61),
      insertSize: 200 + Math.random() * 400,
      y: 0,
      hasDeletion,
      delStart,
      delEnd,
    };
    reads.push(read);

    // Generate some mismatches (SNPs)
    const mismatchCount = Math.floor(Math.random() * 4);
    for (let m = 0; m < mismatchCount; m++) {
      const pos = start + Math.random() * readLength;
      // Skip if in deletion
      if (hasDeletion && pos >= delStart && pos <= delEnd) continue;
      mismatches.push({
        position: Math.floor(pos),
        readIdx: i,
        base: Math.floor(Math.random() * 4), // 0=A, 1=C, 2=G, 3=T
      });
    }

    // Generate some insertions
    if (Math.random() < 0.1) {
      const insPos = start + Math.random() * readLength;
      if (!(hasDeletion && insPos >= delStart && insPos <= delEnd)) {
        insertions.push({
          position: Math.floor(insPos),
          readIdx: i,
        });
      }
    }
  }

  const maxY = computePileupLayout(reads);

  // Now that we have Y positions, update gaps, mismatches, insertions
  for (const read of reads) {
    if (read.hasDeletion) {
      gaps.push({
        start: read.delStart,
        end: read.delEnd,
        y: read.y,
      });
    }
  }

  for (const mm of mismatches) {
    mm.y = reads[mm.readIdx].y;
  }

  for (const ins of insertions) {
    ins.y = reads[ins.readIdx].y;
  }

  return maxY;
}

function createVAO(program, bufferConfigs) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const buffers = {};
  for (const [name, config] of Object.entries(bufferConfigs)) {
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, config.data, gl.STATIC_DRAW);

    const loc = gl.getAttribLocation(program, config.attrib);
    if (loc >= 0) {
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, config.size, gl.FLOAT, false, 0, 0);
      if (config.divisor) {
        gl.vertexAttribDivisor(loc, config.divisor);
      }
    }
    buffers[name] = buffer;
  }

  gl.bindVertexArray(null);
  return { vao, buffers };
}

function uploadToGPU() {
  // Clean up old buffers
  for (const key of ['reads', 'gaps', 'mismatches', 'insertions']) {
    if (gpuData[key]) {
      for (const buf of Object.values(gpuData[key].buffers)) {
        gl.deleteBuffer(buf);
      }
      gl.deleteVertexArray(gpuData[key].vao);
    }
  }

  // Upload reads
  const readPositions = new Float32Array(reads.length * 2);
  const readYs = new Float32Array(reads.length);
  const readStrands = new Float32Array(reads.length);
  const readMapqs = new Float32Array(reads.length);
  const readInsertSizes = new Float32Array(reads.length);

  for (let i = 0; i < reads.length; i++) {
    const r = reads[i];
    readPositions[i * 2] = r.start;
    readPositions[i * 2 + 1] = r.end;
    readYs[i] = r.y;
    readStrands[i] = r.strand;
    readMapqs[i] = r.mapq;
    readInsertSizes[i] = r.insertSize;
  }

  gpuData.reads = createVAO(programs.read, {
    position: { attrib: 'a_position', data: readPositions, size: 2, divisor: 1 },
    y: { attrib: 'a_y', data: readYs, size: 1, divisor: 1 },
    strand: { attrib: 'a_strand', data: readStrands, size: 1, divisor: 1 },
    mapq: { attrib: 'a_mapq', data: readMapqs, size: 1, divisor: 1 },
    insertSize: { attrib: 'a_insertSize', data: readInsertSizes, size: 1, divisor: 1 },
  });
  gpuData.reads.count = reads.length;

  // Upload gaps (deletions)
  if (gaps.length > 0) {
    const gapPositions = new Float32Array(gaps.length * 2);
    const gapYs = new Float32Array(gaps.length);

    for (let i = 0; i < gaps.length; i++) {
      gapPositions[i * 2] = gaps[i].start;
      gapPositions[i * 2 + 1] = gaps[i].end;
      gapYs[i] = gaps[i].y;
    }

    gpuData.gaps = createVAO(programs.gap, {
      position: { attrib: 'a_position', data: gapPositions, size: 2, divisor: 1 },
      y: { attrib: 'a_y', data: gapYs, size: 1, divisor: 1 },
    });
    gpuData.gaps.count = gaps.length;
  } else {
    gpuData.gaps = null;
  }

  // Upload mismatches
  if (mismatches.length > 0) {
    const mmPositions = new Float32Array(mismatches.length);
    const mmYs = new Float32Array(mismatches.length);
    const mmBases = new Float32Array(mismatches.length);

    for (let i = 0; i < mismatches.length; i++) {
      mmPositions[i] = mismatches[i].position;
      mmYs[i] = mismatches[i].y;
      mmBases[i] = mismatches[i].base;
    }

    gpuData.mismatches = createVAO(programs.mismatch, {
      position: { attrib: 'a_position', data: mmPositions, size: 1, divisor: 1 },
      y: { attrib: 'a_y', data: mmYs, size: 1, divisor: 1 },
      base: { attrib: 'a_base', data: mmBases, size: 1, divisor: 1 },
    });
    gpuData.mismatches.count = mismatches.length;
  } else {
    gpuData.mismatches = null;
  }

  // Upload insertions
  if (insertions.length > 0) {
    const insPositions = new Float32Array(insertions.length);
    const insYs = new Float32Array(insertions.length);

    for (let i = 0; i < insertions.length; i++) {
      insPositions[i] = insertions[i].position;
      insYs[i] = insertions[i].y;
    }

    gpuData.insertions = createVAO(programs.insertion, {
      position: { attrib: 'a_position', data: insPositions, size: 1, divisor: 1 },
      y: { attrib: 'a_y', data: insYs, size: 1, divisor: 1 },
    });
    gpuData.insertions.count = insertions.length;
  } else {
    gpuData.insertions = null;
  }

  const totalBytes =
    (reads.length * 6 + gaps.length * 3 + mismatches.length * 3 + insertions.length * 2) * 4;
  console.log(`Uploaded to GPU: ${reads.length} reads, ${gaps.length} gaps, ${mismatches.length} mismatches, ${insertions.length} insertions (${(totalBytes/1024).toFixed(1)} KB)`);
}

// ============ View State ============
let viewState = {
  domainX: [0, 50000],
  rangeY: [0, 100],
  colorScheme: 0,
  showMismatches: true,
  showInsertions: true,
};

let maxY = 100;

// ============ Rendering ============
function render() {
  const displayWidth = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;

  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
    canvas.width = displayWidth;
    canvas.height = displayHeight;
  }

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clearColor(0.12, 0.12, 0.12, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  if (!gpuData.reads) return;

  const bpPerPx = (viewState.domainX[1] - viewState.domainX[0]) / canvas.width;

  // 1. Draw reads
  gl.useProgram(programs.read);
  gl.uniform2f(uniforms.read.domainX, viewState.domainX[0], viewState.domainX[1]);
  gl.uniform2f(uniforms.read.rangeY, viewState.rangeY[0], viewState.rangeY[1]);
  gl.uniform1i(uniforms.read.colorScheme, viewState.colorScheme);

  gl.bindVertexArray(gpuData.reads.vao);
  gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, gpuData.reads.count);

  // 2. Draw gaps (deletions) - dark lines over reads
  if (gpuData.gaps && gpuData.gaps.count > 0) {
    gl.useProgram(programs.gap);
    gl.uniform2f(uniforms.gap.domainX, viewState.domainX[0], viewState.domainX[1]);
    gl.uniform2f(uniforms.gap.rangeY, viewState.rangeY[0], viewState.rangeY[1]);

    gl.bindVertexArray(gpuData.gaps.vao);
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, gpuData.gaps.count);
  }

  // 3. Draw mismatches - only if zoomed in enough
  if (viewState.showMismatches && gpuData.mismatches && gpuData.mismatches.count > 0 && bpPerPx < 50) {
    gl.useProgram(programs.mismatch);
    gl.uniform2f(uniforms.mismatch.domainX, viewState.domainX[0], viewState.domainX[1]);
    gl.uniform2f(uniforms.mismatch.rangeY, viewState.rangeY[0], viewState.rangeY[1]);
    gl.uniform1f(uniforms.mismatch.bpPerPx, bpPerPx);

    gl.bindVertexArray(gpuData.mismatches.vao);
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, gpuData.mismatches.count);
  }

  // 4. Draw insertions
  if (viewState.showInsertions && gpuData.insertions && gpuData.insertions.count > 0 && bpPerPx < 100) {
    gl.useProgram(programs.insertion);
    gl.uniform2f(uniforms.insertion.domainX, viewState.domainX[0], viewState.domainX[1]);
    gl.uniform2f(uniforms.insertion.rangeY, viewState.rangeY[0], viewState.rangeY[1]);

    gl.bindVertexArray(gpuData.insertions.vao);
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, gpuData.insertions.count);
  }

  gl.bindVertexArray(null);

  // Update stats
  document.getElementById('stats').textContent =
    `Domain: ${Math.round(viewState.domainX[0])}-${Math.round(viewState.domainX[1])} | ` +
    `bp/px: ${bpPerPx.toFixed(2)} | ` +
    `Y: ${viewState.rangeY[0].toFixed(0)}-${viewState.rangeY[1].toFixed(0)} | ` +
    `Reads: ${gpuData.reads.count} | Gaps: ${gpuData.gaps?.count || 0} | ` +
    `Mismatches: ${gpuData.mismatches?.count || 0}${bpPerPx >= 50 ? ' (hidden)' : ''} | ` +
    `Insertions: ${gpuData.insertions?.count || 0}${bpPerPx >= 100 ? ' (hidden)' : ''}`;
}

// ============ Interaction ============
let isDragging = false;
let lastMouseX = 0, lastMouseY = 0;

canvas.addEventListener('mousedown', (e) => {
  isDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});

canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mouseleave', () => isDragging = false);

canvas.addEventListener('mousemove', (e) => {
  if (!isDragging) return;

  const dx = e.clientX - lastMouseX;
  const dy = e.clientY - lastMouseY;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;

  const domainWidth = viewState.domainX[1] - viewState.domainX[0];
  const bpPerPx = domainWidth / canvas.width;
  viewState.domainX[0] -= dx * bpPerPx;
  viewState.domainX[1] -= dx * bpPerPx;

  const yRange = viewState.rangeY[1] - viewState.rangeY[0];
  const yPerPx = yRange / canvas.height;
  viewState.rangeY[0] += dy * yPerPx;
  viewState.rangeY[1] += dy * yPerPx;

  if (viewState.rangeY[0] < 0) {
    viewState.rangeY[1] -= viewState.rangeY[0];
    viewState.rangeY[0] = 0;
  }

  render();
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();

  if (e.shiftKey) {
    const panY = e.deltaY * 0.1;
    viewState.rangeY[0] += panY;
    viewState.rangeY[1] += panY;
    if (viewState.rangeY[0] < 0) {
      viewState.rangeY[1] -= viewState.rangeY[0];
      viewState.rangeY[0] = 0;
    }
  } else {
    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseFraction = mouseX / canvas.width;

    const domainWidth = viewState.domainX[1] - viewState.domainX[0];
    const mouseGenomicPos = viewState.domainX[0] + domainWidth * mouseFraction;
    const newWidth = Math.max(50, Math.min(500000, domainWidth * zoomFactor));

    viewState.domainX[0] = mouseGenomicPos - newWidth * mouseFraction;
    viewState.domainX[1] = mouseGenomicPos + newWidth * (1 - mouseFraction);
  }

  render();
});

// ============ Controls ============
document.getElementById('colorScheme').addEventListener('change', (e) => {
  viewState.colorScheme = parseInt(e.target.value);
  render();
});

document.getElementById('readCount').addEventListener('input', (e) => {
  readCount = parseInt(e.target.value);
  document.getElementById('readCountLabel').textContent = readCount;
});

document.getElementById('showMismatches').addEventListener('change', (e) => {
  viewState.showMismatches = e.target.checked;
  render();
});

document.getElementById('showInsertions').addEventListener('change', (e) => {
  viewState.showInsertions = e.target.checked;
  render();
});

document.getElementById('regenerate').addEventListener('click', () => {
  const t0 = performance.now();
  maxY = generateData(readCount);
  const genTime = performance.now() - t0;

  const t1 = performance.now();
  uploadToGPU();
  const uploadTime = performance.now() - t1;

  viewState.rangeY = [0, Math.min(maxY + 5, 150)];
  viewState.domainX = [genomicStart, genomicEnd];

  console.log(`Generated in ${genTime.toFixed(1)}ms, uploaded in ${uploadTime.toFixed(1)}ms`);
  render();
});

// ============ Initialize ============
maxY = generateData(readCount);
uploadToGPU();
viewState.rangeY = [0, Math.min(maxY + 5, 150)];
render();

window.addEventListener('resize', render);
</script>
</body>
</html>
