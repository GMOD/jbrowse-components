// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const WIGGLE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    uvec2 start_end;
    float score;
    float prev_score;
    float row_index;
    float color_r;
    float color_g;
    float color_b;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    int scale_type;
    int rendering_type;
    float num_rows;
    vec2 domain_y;
    float zero;
    float viewport_width;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;
const int RENDERING_TYPE_XYPLOT = 0;
const int RENDERING_TYPE_DENSITY = 1;
const int RENDERING_TYPE_LINE = 2;
const int RENDERING_TYPE_SCATTER = 3;
const int SCALE_TYPE_LOG = 1;
const uint VERTICES_PER_INSTANCE = 6u;

uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 8;
    Instance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.prev_score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.row_index = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]);
    s.color_r = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 5) / 4, 0), 0)[(base + 5) % 4]);
    s.color_g = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 6) / 4, 0), 0)[(base + 6) % 4]);
    s.color_b = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 7) / 4, 0), 0)[(base + 7) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range, float zero) {
    float inf = (1.0 / zero);
    float step_ = (2.0 / bp_range.z);
    float hi_1 = max((split_pos.x - bp_range.x), -(inf));
    float lo_1 = max((split_pos.y - bp_range.y), -(inf));
    return dot(vec3(-1.0, hi_1, lo_1), vec3(1.0, step_, step_));
}

float normalize_score(float score, vec2 domain_y, int scale_type) {
    if ((scale_type == SCALE_TYPE_LOG)) {
        float log_min = log2(max(domain_y.x, 1.0));
        float log_max = log2(max(domain_y.y, 1.0));
        float log_score = log2(max(score, 1.0));
        return clamp(((log_score - log_min) / (log_max - log_min)), 0.0, 1.0);
    }
    return clamp(((score - domain_y.x) / (domain_y.y - domain_y.x)), 0.0, 1.0);
}

float score_to_y(float score_1, vec2 domain_y_1, float height, int scale_type_1) {
    float _e4 = normalize_score(score_1, domain_y_1, scale_type_1);
    return ((1.0 - _e4) * height);
}

float get_row_height(float canvas_height, float num_rows) {
    return (canvas_height / num_rows);
}

float get_row_top(float row_index, float row_height) {
    return (row_index * row_height);
}

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    float sx2_ = 0.0;
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    bool local_5 = false;
    bool local_6 = false;
    bool local_7 = false;
    bool local_8 = false;
    bool local_9 = false;
    bool local_10 = false;
    bool local_11 = false;
    vec3 color = vec3(0.0);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    Instance inst = _fetch_Instance(int(instance_index));
    uint vid = (vertex_index % VERTICES_PER_INSTANCE);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec2 _e20 = hp_split_uint(abs_end);
    vec3 _e23 = _group_0_binding_1_vs.bp_range_x;
    float _e26 = _group_0_binding_1_vs.zero;
    float _e27 = hp_to_clip_x(_e19, _e23, _e26);
    vec3 _e30 = _group_0_binding_1_vs.bp_range_x;
    float _e33 = _group_0_binding_1_vs.zero;
    float _e34 = hp_to_clip_x(_e20, _e30, _e33);
    sx2_ = _e34;
    float _e38 = _group_0_binding_1_vs.viewport_width;
    float min_clip_w = (3.0 / _e38);
    float _e41 = sx2_;
    if (((_e41 - _e27) < min_clip_w)) {
        sx2_ = (_e27 + min_clip_w);
    }
    float _e47 = _group_0_binding_1_vs.canvas_height;
    float _e50 = _group_0_binding_1_vs.num_rows;
    float _e51 = get_row_height(_e47, _e50);
    float _e53 = get_row_top(inst.row_index, _e51);
    float _e56 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip = (2.0 / _e56);
    vec3 inst_color = vec3(inst.color_r, inst.color_g, inst.color_b);
    int _e67 = _group_0_binding_1_vs.rendering_type;
    if ((_e67 == RENDERING_TYPE_LINE)) {
        vec2 _e73 = _group_0_binding_1_vs.domain_y;
        int _e76 = _group_0_binding_1_vs.scale_type;
        float _e77 = score_to_y(inst.score, _e73, _e51, _e76);
        float score_y = (_e77 + _e53);
        vec2 _e82 = _group_0_binding_1_vs.domain_y;
        int _e85 = _group_0_binding_1_vs.scale_type;
        float _e86 = score_to_y(inst.prev_score, _e82, _e51, _e85);
        float prev_y = (_e86 + _e53);
        float clip_score_y = (1.0 - (score_y * px_to_clip));
        float clip_prev_y = (1.0 - (prev_y * px_to_clip));
        switch(vid) {
            case 0u: {
                sx = _e27;
                sy = clip_prev_y;
                break;
            }
            case 1u: {
                sx = _e27;
                sy = clip_score_y;
                break;
            }
            case 2u: {
                sx = _e27;
                sy = clip_score_y;
                break;
            }
            case 3u: {
                float _e94 = sx2_;
                sx = _e94;
                sy = clip_score_y;
                break;
            }
            case 4u: {
                float _e95 = sx2_;
                sx = _e95;
                sy = clip_score_y;
                break;
            }
            default: {
                float _e96 = sx2_;
                sx = _e96;
                sy = clip_score_y;
                break;
            }
        }
    } else {
        int _e99 = _group_0_binding_1_vs.rendering_type;
        if ((_e99 == RENDERING_TYPE_DENSITY)) {
            if (!((vid == 0u))) {
                local = (vid == 2u);
            } else {
                local = true;
            }
            bool _e110 = local;
            if (!(_e110)) {
                local_1 = (vid == 3u);
            } else {
                local_1 = true;
            }
            bool _e117 = local_1;
            float local_x = (_e117 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_2 = (vid == 1u);
            } else {
                local_2 = true;
            }
            bool _e129 = local_2;
            if (!(_e129)) {
                local_3 = (vid == 4u);
            } else {
                local_3 = true;
            }
            bool _e136 = local_3;
            float local_y = (_e136 ? 0.0 : 1.0);
            float _e140 = sx2_;
            sx = mix(_e27, _e140, local_x);
            float row_bot = (_e53 + _e51);
            float sy_top = (1.0 - (_e53 * px_to_clip));
            float sy_bot = (1.0 - (row_bot * px_to_clip));
            sy = mix(sy_bot, sy_top, local_y);
        } else {
            int _e152 = _group_0_binding_1_vs.rendering_type;
            if ((_e152 == RENDERING_TYPE_SCATTER)) {
                if (!((vid == 0u))) {
                    local_4 = (vid == 2u);
                } else {
                    local_4 = true;
                }
                bool _e163 = local_4;
                if (!(_e163)) {
                    local_5 = (vid == 3u);
                } else {
                    local_5 = true;
                }
                bool _e170 = local_5;
                float local_x_1 = (_e170 ? 0.0 : 1.0);
                if (!((vid == 0u))) {
                    local_6 = (vid == 1u);
                } else {
                    local_6 = true;
                }
                bool _e182 = local_6;
                if (!(_e182)) {
                    local_7 = (vid == 4u);
                } else {
                    local_7 = true;
                }
                bool _e189 = local_7;
                float local_y_1 = (_e189 ? 0.0 : 1.0);
                vec2 _e196 = _group_0_binding_1_vs.domain_y;
                int _e199 = _group_0_binding_1_vs.scale_type;
                float _e200 = score_to_y(inst.score, _e196, _e51, _e199);
                float score_y_1 = (_e200 + _e53);
                float sy_top_1 = (1.0 - ((score_y_1 - 1.0) * px_to_clip));
                float sy_bot_1 = (1.0 - ((score_y_1 + 1.0) * px_to_clip));
                float _e212 = sx2_;
                sx = mix(_e27, _e212, local_x_1);
                sy = mix(sy_bot_1, sy_top_1, local_y_1);
            } else {
                if (!((vid == 0u))) {
                    local_8 = (vid == 2u);
                } else {
                    local_8 = true;
                }
                bool _e223 = local_8;
                if (!(_e223)) {
                    local_9 = (vid == 3u);
                } else {
                    local_9 = true;
                }
                bool _e230 = local_9;
                float local_x_2 = (_e230 ? 0.0 : 1.0);
                if (!((vid == 0u))) {
                    local_10 = (vid == 1u);
                } else {
                    local_10 = true;
                }
                bool _e242 = local_10;
                if (!(_e242)) {
                    local_11 = (vid == 4u);
                } else {
                    local_11 = true;
                }
                bool _e249 = local_11;
                float local_y_2 = (_e249 ? 0.0 : 1.0);
                float _e253 = sx2_;
                sx = mix(_e27, _e253, local_x_2);
                vec2 _e258 = _group_0_binding_1_vs.domain_y;
                int _e261 = _group_0_binding_1_vs.scale_type;
                float _e262 = score_to_y(inst.score, _e258, _e51, _e261);
                vec2 _e266 = _group_0_binding_1_vs.domain_y;
                int _e269 = _group_0_binding_1_vs.scale_type;
                float _e270 = score_to_y(0.0, _e266, _e51, _e269);
                float y_top = (min(_e262, _e270) + _e53);
                float y_bot = (max(_e262, _e270) + _e53);
                float sy_top_2 = (1.0 - (y_top * px_to_clip));
                float sy_bot_2 = (1.0 - (y_bot * px_to_clip));
                sy = mix(sy_bot_2, sy_top_2, local_y_2);
            }
        }
    }
    int _e285 = _group_0_binding_1_vs.rendering_type;
    if ((_e285 == RENDERING_TYPE_DENSITY)) {
        vec2 _e291 = _group_0_binding_1_vs.domain_y;
        int _e294 = _group_0_binding_1_vs.scale_type;
        float _e295 = normalize_score(inst.score, _e291, _e294);
        vec2 _e299 = _group_0_binding_1_vs.domain_y;
        int _e302 = _group_0_binding_1_vs.scale_type;
        float _e303 = normalize_score(0.0, _e299, _e302);
        float max_dist = max(_e303, (1.0 - _e303));
        float t = (abs((_e295 - _e303)) / max(max_dist, 0.0001));
        color = mix(vec3(1.0), inst_color, t);
    } else {
        color = inst_color;
    }
    float _e317 = sx;
    float _e318 = sy;
    out_.position = vec4(_e317, _e318, 0.0, 1.0);
    vec3 _e323 = color;
    out_.color = vec4(_e323, 1.0);
    VertexOutput _e326 = out_;
    gl_Position = _e326.position;
    _vs2fs_location0 = _e326.color;
    return;
}

`

export const WIGGLE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;
const int RENDERING_TYPE_XYPLOT = 0;
const int RENDERING_TYPE_DENSITY = 1;
const int RENDERING_TYPE_LINE = 2;
const int RENDERING_TYPE_SCATTER = 3;
const int SCALE_TYPE_LOG = 1;
const uint VERTICES_PER_INSTANCE = 6u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

