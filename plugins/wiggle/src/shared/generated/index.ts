// Auto-generated by compile-shaders.ts from WGSL sources
// Do not edit manually - edit the WGSL sources instead
// Regenerate: pnpm compile-shaders

export const WIGGLE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    uvec2 start_end;
    float score;
    float _pad;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    int scale_type;
    int rendering_type;
    int use_bicolor;
    vec2 domain_y;
    float bicolor_pivot;
    float _pad0_;
    vec3 color;
    float _pad1_;
    vec3 pos_color;
    float _pad2_;
    vec3 neg_color;
    float _pad3_;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 4;
    Instance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s._pad = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

layout(location = 0) smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

float normalize_score(float score, vec2 domain_y, int scale_type) {
    if ((scale_type == 1)) {
        float log_min = log2(max(domain_y.x, 1.0));
        float log_max = log2(max(domain_y.y, 1.0));
        float log_score = log2(max(score, 1.0));
        return clamp(((log_score - log_min) / (log_max - log_min)), 0.0, 1.0);
    }
    return clamp(((score - domain_y.x) / (domain_y.y - domain_y.x)), 0.0, 1.0);
}

float score_to_y(float score_1, vec2 domain_y_1, float height, int scale_type_1) {
    float _e4 = normalize_score(score_1, domain_y_1, scale_type_1);
    return ((1.0 - _e4) * height);
}

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    bool local_5 = false;
    bool local_6 = false;
    bool local_7 = false;
    vec3 color = vec3(0.0);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    Instance inst = _fetch_Instance(int(instance_index));
    uint vid = (vertex_index % 6u);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec2 _e20 = hp_split_uint(abs_end);
    vec3 _e23 = _group_0_binding_1_vs.bp_range_x;
    float _e24 = hp_to_clip_x(_e19, _e23);
    vec3 _e27 = _group_0_binding_1_vs.bp_range_x;
    float _e28 = hp_to_clip_x(_e20, _e27);
    float _e33 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip = (2.0 / _e33);
    int _e38 = _group_0_binding_1_vs.rendering_type;
    if ((_e38 == 2)) {
        vec2 _e44 = _group_0_binding_1_vs.domain_y;
        float _e47 = _group_0_binding_1_vs.canvas_height;
        int _e50 = _group_0_binding_1_vs.scale_type;
        float _e51 = score_to_y(inst.score, _e44, _e47, _e50);
        uint safe_prev_idx = (max(instance_index, 1u) - 1u);
        float _e59 = _group_0_binding_0_vs[safe_prev_idx].score;
        float prev_score = ((instance_index == 0u) ? inst.score : _e59);
        vec2 _e66 = _group_0_binding_1_vs.domain_y;
        float _e69 = _group_0_binding_1_vs.canvas_height;
        int _e72 = _group_0_binding_1_vs.scale_type;
        float _e73 = score_to_y(prev_score, _e66, _e69, _e72);
        float clip_score_y = (1.0 - (_e51 * px_to_clip));
        float clip_prev_y = (1.0 - (_e73 * px_to_clip));
        switch(vid) {
            case 0u: {
                sx = _e24;
                sy = clip_prev_y;
                break;
            }
            case 1u: {
                sx = _e24;
                sy = clip_score_y;
                break;
            }
            case 2u: {
                sx = _e24;
                sy = clip_score_y;
                break;
            }
            case 3u: {
                sx = _e28;
                sy = clip_score_y;
                break;
            }
            case 4u: {
                sx = _e28;
                sy = clip_score_y;
                break;
            }
            default: {
                sx = _e28;
                sy = clip_score_y;
                break;
            }
        }
    } else {
        int _e82 = _group_0_binding_1_vs.rendering_type;
        if ((_e82 == 1)) {
            if (!((vid == 0u))) {
                local = (vid == 2u);
            } else {
                local = true;
            }
            bool _e93 = local;
            if (!(_e93)) {
                local_1 = (vid == 3u);
            } else {
                local_1 = true;
            }
            bool _e100 = local_1;
            float local_x = (_e100 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_2 = (vid == 1u);
            } else {
                local_2 = true;
            }
            bool _e112 = local_2;
            if (!(_e112)) {
                local_3 = (vid == 4u);
            } else {
                local_3 = true;
            }
            bool _e119 = local_3;
            float local_y = (_e119 ? 0.0 : 1.0);
            sx = mix(_e24, _e28, local_x);
            sy = mix(-1.0, 1.0, local_y);
        } else {
            if (!((vid == 0u))) {
                local_4 = (vid == 2u);
            } else {
                local_4 = true;
            }
            bool _e135 = local_4;
            if (!(_e135)) {
                local_5 = (vid == 3u);
            } else {
                local_5 = true;
            }
            bool _e142 = local_5;
            float local_x_1 = (_e142 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_6 = (vid == 1u);
            } else {
                local_6 = true;
            }
            bool _e154 = local_6;
            if (!(_e154)) {
                local_7 = (vid == 4u);
            } else {
                local_7 = true;
            }
            bool _e161 = local_7;
            float local_y_1 = (_e161 ? 0.0 : 1.0);
            sx = mix(_e24, _e28, local_x_1);
            vec2 _e169 = _group_0_binding_1_vs.domain_y;
            float _e172 = _group_0_binding_1_vs.canvas_height;
            int _e175 = _group_0_binding_1_vs.scale_type;
            float _e176 = score_to_y(inst.score, _e169, _e172, _e175);
            vec2 _e180 = _group_0_binding_1_vs.domain_y;
            float _e183 = _group_0_binding_1_vs.canvas_height;
            int _e186 = _group_0_binding_1_vs.scale_type;
            float _e187 = score_to_y(0.0, _e180, _e183, _e186);
            float y_top = min(_e176, _e187);
            float y_bot = max(_e176, _e187);
            float sy_top = (1.0 - (y_top * px_to_clip));
            float sy_bot = (1.0 - (y_bot * px_to_clip));
            sy = mix(sy_bot, sy_top, local_y_1);
        }
    }
    int _e200 = _group_0_binding_1_vs.use_bicolor;
    if ((_e200 == 1)) {
        int _e205 = _group_0_binding_1_vs.rendering_type;
        if ((_e205 == 1)) {
            vec2 _e211 = _group_0_binding_1_vs.domain_y;
            int _e214 = _group_0_binding_1_vs.scale_type;
            float _e215 = normalize_score(inst.score, _e211, _e214);
            float _e218 = _group_0_binding_1_vs.bicolor_pivot;
            vec2 _e221 = _group_0_binding_1_vs.domain_y;
            int _e224 = _group_0_binding_1_vs.scale_type;
            float _e225 = normalize_score(_e218, _e221, _e224);
            vec3 _e228 = _group_0_binding_1_vs.pos_color;
            vec3 _e231 = _group_0_binding_1_vs.neg_color;
            color = ((_e215 < _e225) ? _e231 : _e228);
        } else {
            vec3 _e236 = _group_0_binding_1_vs.pos_color;
            vec3 _e239 = _group_0_binding_1_vs.neg_color;
            float _e243 = _group_0_binding_1_vs.bicolor_pivot;
            color = ((inst.score < _e243) ? _e239 : _e236);
        }
    } else {
        int _e248 = _group_0_binding_1_vs.rendering_type;
        if ((_e248 == 1)) {
            vec2 _e254 = _group_0_binding_1_vs.domain_y;
            int _e257 = _group_0_binding_1_vs.scale_type;
            float _e258 = normalize_score(inst.score, _e254, _e257);
            vec3 low_color = vec3(0.93, 0.93, 0.93);
            vec3 _e265 = _group_0_binding_1_vs.pos_color;
            color = mix(low_color, _e265, _e258);
        } else {
            vec3 _e269 = _group_0_binding_1_vs.color;
            color = _e269;
        }
    }
    float _e272 = sx;
    float _e273 = sy;
    out_.position = vec4(_e272, _e273, 0.0, 1.0);
    vec3 _e278 = color;
    out_.color = vec4(_e278, 1.0);
    VertexOutput _e281 = out_;
    gl_Position = _e281.position;
    _vs2fs_location0 = _e281.color;
    return;
}

`

export const WIGGLE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

layout(location = 0) smooth in vec4 _vs2fs_location0;
layout(location = 0) out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

export const MULTI_WIGGLE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    uvec2 start_end;
    float score;
    float prev_score;
    float row_index;
    float color_r;
    float color_g;
    float color_b;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    int scale_type;
    int rendering_type;
    float num_rows;
    vec2 domain_y;
    float row_padding;
    float _pad;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 8;
    Instance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.prev_score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.row_index = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]);
    s.color_r = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 5) / 4, 0), 0)[(base + 5) % 4]);
    s.color_g = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 6) / 4, 0), 0)[(base + 6) % 4]);
    s.color_b = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 7) / 4, 0), 0)[(base + 7) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

layout(location = 0) smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range) {
    float hi_1 = (split_pos.x - bp_range.x);
    float lo_1 = (split_pos.y - bp_range.y);
    return ((((hi_1 + lo_1) / bp_range.z) * 2.0) - 1.0);
}

float normalize_score(float score, vec2 domain_y, int scale_type) {
    if ((scale_type == 1)) {
        float log_min = log2(max(domain_y.x, 1.0));
        float log_max = log2(max(domain_y.y, 1.0));
        float log_score = log2(max(score, 1.0));
        return clamp(((log_score - log_min) / (log_max - log_min)), 0.0, 1.0);
    }
    return clamp(((score - domain_y.x) / (domain_y.y - domain_y.x)), 0.0, 1.0);
}

float score_to_y(float score_1, vec2 domain_y_1, float height, int scale_type_1) {
    float _e4 = normalize_score(score_1, domain_y_1, scale_type_1);
    return ((1.0 - _e4) * height);
}

float get_row_height(float canvas_height, float num_rows, float row_padding) {
    float total_padding = (row_padding * (num_rows - 1.0));
    return ((canvas_height - total_padding) / num_rows);
}

float get_row_top(float row_index, float row_height, float row_padding_1) {
    return (row_index * (row_height + row_padding_1));
}

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    bool local_5 = false;
    bool local_6 = false;
    bool local_7 = false;
    vec3 color = vec3(0.0);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    Instance inst = _fetch_Instance(int(instance_index));
    uint vid = (vertex_index % 6u);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec2 _e20 = hp_split_uint(abs_end);
    vec3 _e23 = _group_0_binding_1_vs.bp_range_x;
    float _e24 = hp_to_clip_x(_e19, _e23);
    vec3 _e27 = _group_0_binding_1_vs.bp_range_x;
    float _e28 = hp_to_clip_x(_e20, _e27);
    float _e31 = _group_0_binding_1_vs.canvas_height;
    float _e34 = _group_0_binding_1_vs.num_rows;
    float _e37 = _group_0_binding_1_vs.row_padding;
    float _e38 = get_row_height(_e31, _e34, _e37);
    float _e42 = _group_0_binding_1_vs.row_padding;
    float _e43 = get_row_top(inst.row_index, _e38, _e42);
    float _e46 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip = (2.0 / _e46);
    vec3 inst_color = vec3(inst.color_r, inst.color_g, inst.color_b);
    int _e57 = _group_0_binding_1_vs.rendering_type;
    if ((_e57 == 2)) {
        vec2 _e63 = _group_0_binding_1_vs.domain_y;
        int _e66 = _group_0_binding_1_vs.scale_type;
        float _e67 = score_to_y(inst.score, _e63, _e38, _e66);
        float score_y = (_e67 + _e43);
        vec2 _e72 = _group_0_binding_1_vs.domain_y;
        int _e75 = _group_0_binding_1_vs.scale_type;
        float _e76 = score_to_y(inst.prev_score, _e72, _e38, _e75);
        float prev_y = (_e76 + _e43);
        float clip_score_y = (1.0 - (score_y * px_to_clip));
        float clip_prev_y = (1.0 - (prev_y * px_to_clip));
        switch(vid) {
            case 0u: {
                sx = _e24;
                sy = clip_prev_y;
                break;
            }
            case 1u: {
                sx = _e24;
                sy = clip_score_y;
                break;
            }
            case 2u: {
                sx = _e24;
                sy = clip_score_y;
                break;
            }
            case 3u: {
                sx = _e28;
                sy = clip_score_y;
                break;
            }
            case 4u: {
                sx = _e28;
                sy = clip_score_y;
                break;
            }
            default: {
                sx = _e28;
                sy = clip_score_y;
                break;
            }
        }
    } else {
        int _e86 = _group_0_binding_1_vs.rendering_type;
        if ((_e86 == 1)) {
            if (!((vid == 0u))) {
                local = (vid == 2u);
            } else {
                local = true;
            }
            bool _e97 = local;
            if (!(_e97)) {
                local_1 = (vid == 3u);
            } else {
                local_1 = true;
            }
            bool _e104 = local_1;
            float local_x = (_e104 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_2 = (vid == 1u);
            } else {
                local_2 = true;
            }
            bool _e116 = local_2;
            if (!(_e116)) {
                local_3 = (vid == 4u);
            } else {
                local_3 = true;
            }
            bool _e123 = local_3;
            float local_y = (_e123 ? 0.0 : 1.0);
            sx = mix(_e24, _e28, local_x);
            float row_bot = (_e43 + _e38);
            float sy_top = (1.0 - (_e43 * px_to_clip));
            float sy_bot = (1.0 - (row_bot * px_to_clip));
            sy = mix(sy_bot, sy_top, local_y);
        } else {
            if (!((vid == 0u))) {
                local_4 = (vid == 2u);
            } else {
                local_4 = true;
            }
            bool _e144 = local_4;
            if (!(_e144)) {
                local_5 = (vid == 3u);
            } else {
                local_5 = true;
            }
            bool _e151 = local_5;
            float local_x_1 = (_e151 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_6 = (vid == 1u);
            } else {
                local_6 = true;
            }
            bool _e163 = local_6;
            if (!(_e163)) {
                local_7 = (vid == 4u);
            } else {
                local_7 = true;
            }
            bool _e170 = local_7;
            float local_y_1 = (_e170 ? 0.0 : 1.0);
            sx = mix(_e24, _e28, local_x_1);
            vec2 _e178 = _group_0_binding_1_vs.domain_y;
            int _e181 = _group_0_binding_1_vs.scale_type;
            float _e182 = score_to_y(inst.score, _e178, _e38, _e181);
            vec2 _e186 = _group_0_binding_1_vs.domain_y;
            int _e189 = _group_0_binding_1_vs.scale_type;
            float _e190 = score_to_y(0.0, _e186, _e38, _e189);
            float y_top = (min(_e182, _e190) + _e43);
            float y_bot = (max(_e182, _e190) + _e43);
            float sy_top_1 = (1.0 - (y_top * px_to_clip));
            float sy_bot_1 = (1.0 - (y_bot * px_to_clip));
            sy = mix(sy_bot_1, sy_top_1, local_y_1);
        }
    }
    int _e205 = _group_0_binding_1_vs.rendering_type;
    if ((_e205 == 1)) {
        vec2 _e211 = _group_0_binding_1_vs.domain_y;
        int _e214 = _group_0_binding_1_vs.scale_type;
        float _e215 = normalize_score(inst.score, _e211, _e214);
        vec3 low_color = vec3(0.93, 0.93, 0.93);
        color = mix(low_color, inst_color, _e215);
    } else {
        color = inst_color;
    }
    float _e223 = sx;
    float _e224 = sy;
    out_.position = vec4(_e223, _e224, 0.0, 1.0);
    vec3 _e229 = color;
    out_.color = vec4(_e229, 1.0);
    VertexOutput _e232 = out_;
    gl_Position = _e232.position;
    _vs2fs_location0 = _e232.color;
    return;
}

`

export const MULTI_WIGGLE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;

layout(location = 0) smooth in vec4 _vs2fs_location0;
layout(location = 0) out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

