// Auto-generated by compile-shaders.ts from WGSL sources
// Regenerate: pnpm compile-shaders

export const WIGGLE_VERTEX_SHADER = `#version 300 es

precision highp float;
precision highp int;


struct Instance {
    uvec2 start_end;
    float score;
    float prev_score;
    float row_index;
    float color_r;
    float color_g;
    float color_b;
};
struct Uniforms {
    vec3 bp_range_x;
    uint region_start;
    float canvas_height;
    int scale_type;
    int rendering_type;
    float num_rows;
    vec2 domain_y;
    float row_padding;
    float zero;
};
struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;
const int RENDERING_TYPE_XYPLOT = 0;
const int RENDERING_TYPE_DENSITY = 1;
const int RENDERING_TYPE_LINE = 2;
const int SCALE_TYPE_LOG = 1;
const uint VERTICES_PER_INSTANCE = 6u;

uniform highp usampler2D u_instanceData;

Instance _fetch_Instance(int idx) {
    int base = idx * 8;
    Instance s;
    s.start_end = uvec2(texelFetch(u_instanceData, ivec2((base + 0) / 4, 0), 0)[(base + 0) % 4], texelFetch(u_instanceData, ivec2((base + 0 + 1) / 4, 0), 0)[(base + 0 + 1) % 4]);
    s.score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 2) / 4, 0), 0)[(base + 2) % 4]);
    s.prev_score = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 3) / 4, 0), 0)[(base + 3) % 4]);
    s.row_index = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 4) / 4, 0), 0)[(base + 4) % 4]);
    s.color_r = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 5) / 4, 0), 0)[(base + 5) % 4]);
    s.color_g = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 6) / 4, 0), 0)[(base + 6) % 4]);
    s.color_b = uintBitsToFloat(texelFetch(u_instanceData, ivec2((base + 7) / 4, 0), 0)[(base + 7) % 4]);
    return s;
}

layout(std140) uniform Uniforms_block_1Vertex { Uniforms _group_0_binding_1_vs; };

smooth out vec4 _vs2fs_location0;

vec2 hp_split_uint(uint value) {
    uint lo = (value & HP_LOW_MASK);
    uint hi = (value - lo);
    return vec2(float(hi), float(lo));
}

float hp_to_clip_x(vec2 split_pos, vec3 bp_range, float zero) {
    float inf = (1.0 / zero);
    float step_ = (2.0 / bp_range.z);
    float hi_1 = max((split_pos.x - bp_range.x), -(inf));
    float lo_1 = max((split_pos.y - bp_range.y), -(inf));
    return dot(vec3(-1.0, hi_1, lo_1), vec3(1.0, step_, step_));
}

float normalize_score(float score, vec2 domain_y, int scale_type) {
    if ((scale_type == SCALE_TYPE_LOG)) {
        float log_min = log2(max(domain_y.x, 1.0));
        float log_max = log2(max(domain_y.y, 1.0));
        float log_score = log2(max(score, 1.0));
        return clamp(((log_score - log_min) / (log_max - log_min)), 0.0, 1.0);
    }
    return clamp(((score - domain_y.x) / (domain_y.y - domain_y.x)), 0.0, 1.0);
}

float score_to_y(float score_1, vec2 domain_y_1, float height, int scale_type_1) {
    float _e4 = normalize_score(score_1, domain_y_1, scale_type_1);
    return ((1.0 - _e4) * height);
}

float get_row_height(float canvas_height, float num_rows, float row_padding) {
    float total_padding = (row_padding * (num_rows - 1.0));
    return ((canvas_height - total_padding) / num_rows);
}

float get_row_top(float row_index, float row_height, float row_padding_1) {
    return (row_index * (row_height + row_padding_1));
}

void main() {
    uint vertex_index = uint(gl_VertexID);
    uint instance_index = uint(gl_InstanceID);
    float sx = 0.0;
    float sy = 0.0;
    bool local = false;
    bool local_1 = false;
    bool local_2 = false;
    bool local_3 = false;
    bool local_4 = false;
    bool local_5 = false;
    bool local_6 = false;
    bool local_7 = false;
    vec3 color = vec3(0.0);
    VertexOutput out_ = VertexOutput(vec4(0.0), vec4(0.0));
    Instance inst = _fetch_Instance(int(instance_index));
    uint vid = (vertex_index % VERTICES_PER_INSTANCE);
    uint _e11 = _group_0_binding_1_vs.region_start;
    uint abs_start = (inst.start_end.x + _e11);
    uint _e17 = _group_0_binding_1_vs.region_start;
    uint abs_end = (inst.start_end.y + _e17);
    vec2 _e19 = hp_split_uint(abs_start);
    vec2 _e20 = hp_split_uint(abs_end);
    vec3 _e23 = _group_0_binding_1_vs.bp_range_x;
    float _e26 = _group_0_binding_1_vs.zero;
    float _e27 = hp_to_clip_x(_e19, _e23, _e26);
    vec3 _e30 = _group_0_binding_1_vs.bp_range_x;
    float _e33 = _group_0_binding_1_vs.zero;
    float _e34 = hp_to_clip_x(_e20, _e30, _e33);
    float _e37 = _group_0_binding_1_vs.canvas_height;
    float _e40 = _group_0_binding_1_vs.num_rows;
    float _e43 = _group_0_binding_1_vs.row_padding;
    float _e44 = get_row_height(_e37, _e40, _e43);
    float _e48 = _group_0_binding_1_vs.row_padding;
    float _e49 = get_row_top(inst.row_index, _e44, _e48);
    float _e52 = _group_0_binding_1_vs.canvas_height;
    float px_to_clip = (2.0 / _e52);
    vec3 inst_color = vec3(inst.color_r, inst.color_g, inst.color_b);
    int _e63 = _group_0_binding_1_vs.rendering_type;
    if ((_e63 == RENDERING_TYPE_LINE)) {
        vec2 _e69 = _group_0_binding_1_vs.domain_y;
        int _e72 = _group_0_binding_1_vs.scale_type;
        float _e73 = score_to_y(inst.score, _e69, _e44, _e72);
        float score_y = (_e73 + _e49);
        vec2 _e78 = _group_0_binding_1_vs.domain_y;
        int _e81 = _group_0_binding_1_vs.scale_type;
        float _e82 = score_to_y(inst.prev_score, _e78, _e44, _e81);
        float prev_y = (_e82 + _e49);
        float clip_score_y = (1.0 - (score_y * px_to_clip));
        float clip_prev_y = (1.0 - (prev_y * px_to_clip));
        switch(vid) {
            case 0u: {
                sx = _e27;
                sy = clip_prev_y;
                break;
            }
            case 1u: {
                sx = _e27;
                sy = clip_score_y;
                break;
            }
            case 2u: {
                sx = _e27;
                sy = clip_score_y;
                break;
            }
            case 3u: {
                sx = _e34;
                sy = clip_score_y;
                break;
            }
            case 4u: {
                sx = _e34;
                sy = clip_score_y;
                break;
            }
            default: {
                sx = _e34;
                sy = clip_score_y;
                break;
            }
        }
    } else {
        int _e92 = _group_0_binding_1_vs.rendering_type;
        if ((_e92 == RENDERING_TYPE_DENSITY)) {
            if (!((vid == 0u))) {
                local = (vid == 2u);
            } else {
                local = true;
            }
            bool _e103 = local;
            if (!(_e103)) {
                local_1 = (vid == 3u);
            } else {
                local_1 = true;
            }
            bool _e110 = local_1;
            float local_x = (_e110 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_2 = (vid == 1u);
            } else {
                local_2 = true;
            }
            bool _e122 = local_2;
            if (!(_e122)) {
                local_3 = (vid == 4u);
            } else {
                local_3 = true;
            }
            bool _e129 = local_3;
            float local_y = (_e129 ? 0.0 : 1.0);
            sx = mix(_e27, _e34, local_x);
            float row_bot = (_e49 + _e44);
            float sy_top = (1.0 - (_e49 * px_to_clip));
            float sy_bot = (1.0 - (row_bot * px_to_clip));
            sy = mix(sy_bot, sy_top, local_y);
        } else {
            if (!((vid == 0u))) {
                local_4 = (vid == 2u);
            } else {
                local_4 = true;
            }
            bool _e150 = local_4;
            if (!(_e150)) {
                local_5 = (vid == 3u);
            } else {
                local_5 = true;
            }
            bool _e157 = local_5;
            float local_x_1 = (_e157 ? 0.0 : 1.0);
            if (!((vid == 0u))) {
                local_6 = (vid == 1u);
            } else {
                local_6 = true;
            }
            bool _e169 = local_6;
            if (!(_e169)) {
                local_7 = (vid == 4u);
            } else {
                local_7 = true;
            }
            bool _e176 = local_7;
            float local_y_1 = (_e176 ? 0.0 : 1.0);
            sx = mix(_e27, _e34, local_x_1);
            vec2 _e184 = _group_0_binding_1_vs.domain_y;
            int _e187 = _group_0_binding_1_vs.scale_type;
            float _e188 = score_to_y(inst.score, _e184, _e44, _e187);
            vec2 _e192 = _group_0_binding_1_vs.domain_y;
            int _e195 = _group_0_binding_1_vs.scale_type;
            float _e196 = score_to_y(0.0, _e192, _e44, _e195);
            float y_top = (min(_e188, _e196) + _e49);
            float y_bot = (max(_e188, _e196) + _e49);
            float sy_top_1 = (1.0 - (y_top * px_to_clip));
            float sy_bot_1 = (1.0 - (y_bot * px_to_clip));
            sy = mix(sy_bot_1, sy_top_1, local_y_1);
        }
    }
    int _e211 = _group_0_binding_1_vs.rendering_type;
    if ((_e211 == RENDERING_TYPE_DENSITY)) {
        vec2 _e217 = _group_0_binding_1_vs.domain_y;
        int _e220 = _group_0_binding_1_vs.scale_type;
        float _e221 = normalize_score(inst.score, _e217, _e220);
        vec2 _e225 = _group_0_binding_1_vs.domain_y;
        int _e228 = _group_0_binding_1_vs.scale_type;
        float _e229 = normalize_score(0.0, _e225, _e228);
        float max_dist = max(_e229, (1.0 - _e229));
        float t = (abs((_e221 - _e229)) / max(max_dist, 0.0001));
        color = mix(vec3(1.0), inst_color, t);
    } else {
        color = inst_color;
    }
    float _e243 = sx;
    float _e244 = sy;
    out_.position = vec4(_e243, _e244, 0.0, 1.0);
    vec3 _e249 = color;
    out_.color = vec4(_e249, 1.0);
    VertexOutput _e252 = out_;
    gl_Position = _e252.position;
    _vs2fs_location0 = _e252.color;
    return;
}

`

export const WIGGLE_FRAGMENT_SHADER = `#version 300 es

precision highp float;
precision highp int;

struct VertexOutput {
    vec4 position;
    vec4 color;
};
const uint HP_LOW_MASK = 4095u;
const int RENDERING_TYPE_XYPLOT = 0;
const int RENDERING_TYPE_DENSITY = 1;
const int RENDERING_TYPE_LINE = 2;
const int SCALE_TYPE_LOG = 1;
const uint VERTICES_PER_INSTANCE = 6u;

smooth in vec4 _vs2fs_location0;
out vec4 _fs2p_location0;

void main() {
    VertexOutput in_ = VertexOutput(gl_FragCoord, _vs2fs_location0);
    _fs2p_location0 = in_.color;
    return;
}

`

